<!-- spreadsheet-functions.html - スプレッドシート関連JavaScript -->
<script>
  // ========================================
  // スプレッドシート関連関数
  // ========================================
  
  // showDebugInfo関数が存在しない場合の代替実装
  if (typeof showDebugInfo !== 'function') {
    window.showDebugInfo = function(message, data) {
      if (typeof DEBUG_MODE === 'undefined' || !DEBUG_MODE) return;
      
      const debugInfo = document.getElementById('debugInfo');
      const timestamp = new Date().toISOString();
      const debugMessage = `[${timestamp}] ${message}\n${JSON.stringify(data, null, 2)}\n\n`;
      
      if (debugInfo) {
        debugInfo.textContent = (debugInfo.textContent || '') + debugMessage;
        // スクロールを最下部に
        debugInfo.scrollTop = debugInfo.scrollHeight;
      } else {
        console.log(`[DEBUG] ${message}`, data);
      }
    };
  }
  
  // showServerLogs関数が存在しない場合の代替実装
  if (typeof showServerLogs !== 'function') {
    window.showServerLogs = function(logs) {
      if (typeof DEBUG_MODE === 'undefined' || !DEBUG_MODE) return;
      if (!logs || !Array.isArray(logs)) return;
      
      const debugInfo = document.getElementById('debugInfo');
      logs.forEach(log => {
        const debugMessage = `[SERVER ${log.timestamp}] ${log.message}\n${JSON.stringify(log.data, null, 2)}\n\n`;
        
        if (debugInfo) {
          debugInfo.textContent = (debugInfo.textContent || '') + debugMessage;
          debugInfo.scrollTop = debugInfo.scrollHeight;
        } else {
          console.log(`[SERVER DEBUG] ${log.message}`, log.data);
        }
      });
    };
  }
  
  // 拠点マスタデータ（動的読み込み）
  let spreadsheetLocationMasterData = [];
  
  // データタイプマスタデータ（動的読み込み）
  let dataTypeMasterData = [];
  
  // 拠点IDから拠点名を取得（拠点マスタベース）
  function getLocationNameByIdSpreadsheet(locationId) {
    if (spreadsheetLocationMasterData && spreadsheetLocationMasterData.length > 0) {
      const location = spreadsheetLocationMasterData.find(loc => loc.locationId === locationId);
      return location ? location.locationName : locationId;
    }
    return locationId;
  }
  
  // 拠点マスタデータを読み込み
  function loadLocationMasterForSpreadsheet() {
    google.script.run
      .withSuccessHandler(function(locations) {
        spreadsheetLocationMasterData = locations || [];
        console.log('拠点マスタデータ読み込み完了（スプレッドシート）:', spreadsheetLocationMasterData);
      })
      .withFailureHandler(function(error) {
        console.error('拠点マスタデータ読み込み失敗（スプレッドシート）:', error);
        spreadsheetLocationMasterData = [];
      })
      .getLocationMaster();
  }
  
  // 拠点一覧を取得してプルダウンメニューに設定
  function initializeLocations() {
    // 拠点マスタを読み込み
    loadLocationMasterForSpreadsheet();
    
    // データタイプマスタを読み込み
    loadDataTypeMaster();
    
    google.script.run
      .withSuccessHandler(function(response) {
        if (response.success) {
          const locationSelect = document.getElementById('location');
          Object.entries(response.locations).forEach(([key, name]) => {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = name;
            locationSelect.appendChild(option);
          });
        }
        // 初期表示時はローディング非表示
        document.getElementById('loading').style.display = 'none';
      })
      .withFailureHandler(function(error) {
        const errorDiv = document.getElementById('error');
        errorDiv.textContent = '拠点一覧の取得に失敗しました: ' + error;
      })
      .getLocations();
  }
  
  // データタイプマスタを読み込み
  function loadDataTypeMaster() {
    google.script.run
      .withSuccessHandler(function(response) {
        if (response.success) {
          dataTypeMasterData = response.dataTypes || [];
          console.log('データタイプマスタ読み込み完了:', dataTypeMasterData);
          
          // データタイプドロップダウンを更新
          const dataTypeSelect = document.getElementById('dataType');
          if (dataTypeSelect) {
            dataTypeSelect.innerHTML = '<option value="">データタイプを選択してください</option>';
            
            dataTypeMasterData.forEach(dataType => {
              const option = document.createElement('option');
              option.value = dataType.dataTypeId;
              option.textContent = dataType.dataTypeName;
              if (dataType.description) {
                option.title = dataType.description;
              }
              // デフォルトでNORMALを選択
              if (dataType.dataTypeId === 'NORMAL') {
                option.selected = true;
              }
              dataTypeSelect.appendChild(option);
            });
            
            // デフォルトでNORMALが選択されている場合、UIを更新
            if (dataTypeSelect.value === 'NORMAL') {
              handleDataTypeChange();
            }
          }
        }
      })
      .withFailureHandler(function(error) {
        console.error('データタイプマスタ読み込み失敗:', error);
        dataTypeMasterData = [];
        
        // エラー時のフォールバック
        const dataTypeSelect = document.getElementById('dataType');
        if (dataTypeSelect) {
          dataTypeSelect.innerHTML = '<option value="">データタイプの読み込みに失敗しました</option>';
        }
      })
      .getDataTypeMaster(true); // アクティブなデータタイプのみ取得
  }

  // デバイスタイプ変更時の処理
  function handleDeviceTypeChange() {
    const locationSelect = document.getElementById('location');
    if (locationSelect && locationSelect.value) {
      // 拠点が既に選択されている場合は再読み込み
      handleLocationChange();
    }
  }

  // 拠点が変更されたときの処理
  function handleLocationChange() {
    const locationSelect = document.getElementById('location');
    const selectedLocation = locationSelect.value;
    const deviceTypeSelect = document.getElementById('deviceType');
    const selectedDeviceType = deviceTypeSelect ? deviceTypeSelect.value : 'terminal';
    const querySelector = document.querySelector('.query-selector');
    const refreshButton = document.getElementById('refreshButton');
    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');
    
    // エラーとテーブルを初期クリア
    errorDiv.textContent = '';
    tableContainer.innerHTML = '';
    loadingDiv.style.display = 'none';
    
    if (selectedLocation) {
      // バックグラウンド読み込み状況をチェック
      const loadStatus = typeof getBackgroundLoadStatus === 'function' ? 
        getBackgroundLoadStatus(selectedLocation) : 'not_started';
      
      if (DEBUG_MODE) {
        showDebugInfo('拠点変更：読み込み状況チェック', { 
          location: selectedLocation, 
          loadStatus: loadStatus 
        });
      }
      
      if (loadStatus === 'completed' && isDataPreloaded(selectedLocation)) {
        // データ読み込み済み：即座に表示
        currentLocation = selectedLocation;
        querySelector.style.display = 'block';
        
        if (refreshButton) {
          refreshButton.disabled = false;
        }
        
        // 該当拠点の最終更新時刻を表示
        displayLocationUpdateTime(selectedLocation);
        
        const queryType = document.querySelector('input[name="queryType"]:checked')?.value || 'all';
        loadSpreadsheet(selectedLocation, queryType, selectedDeviceType);
        return;
        
      } else if (loadStatus === 'error') {
        // 読み込みエラー（スプレッドシートID未設定など）
        currentLocation = '';
        querySelector.style.display = 'none';
        
        if (refreshButton) {
          refreshButton.disabled = true;
        }
        
        const locationName = getLocationNameByIdSpreadsheet(selectedLocation);
        
        errorDiv.textContent = `${locationName}のスプレッドシートIDが設定されていません。システム管理者にお問い合わせください。`;
        tableContainer.innerHTML = `
          <div class="error-message">
            <i class="fas fa-exclamation-triangle"></i>
            <h3>設定エラー</h3>
            <p>${locationName}のスプレッドシートIDが設定されていません。</p>
            <p class="error-detail">この拠点のデータを表示するには、システム管理者にスプレッドシートIDの設定を依頼してください。</p>
          </div>
        `;
        
        locationSelect.value = '';
        return;
        
      } else {
        // 読み込み中または未開始：読み込み表示してからデータ取得
        currentLocation = selectedLocation;
        querySelector.style.display = 'block';
        
        if (refreshButton) {
          refreshButton.disabled = false;
        }
        
        // 該当拠点の最終更新時刻を表示（あれば）
        displayLocationUpdateTime(selectedLocation);
        
        // 読み込み表示
        loadingDiv.style.display = 'block';
        tableContainer.innerHTML = `
          <div class="background-loading-message">
            <i class="fas fa-sync-alt fa-spin"></i>
            <h3>データを読み込み中...</h3>
            <p>選択された拠点のデータを取得しています。</p>
            <p class="loading-detail">初回アクセス時やバックグラウンド読み込み中は、少しお時間をいただく場合があります。</p>
          </div>
        `;
        
        const queryType = document.querySelector('input[name="queryType"]:checked')?.value || 'all';
        
        // データ取得を実行
        loadSpreadsheetDirectly(selectedLocation, queryType, selectedDeviceType);
        return;
      }
      
    } else {
      // 拠点が選択されていない場合
      currentLocation = '';
      querySelector.style.display = 'none';
      
      if (refreshButton) {
        refreshButton.disabled = true;
      }
      
      // 時刻表示を隠す
      const lastUpdateElement = document.getElementById('lastUpdateTime');
      if (lastUpdateElement) {
        lastUpdateElement.style.display = 'none';
      }
    }
  }

  // 直接データ取得（バックグラウンド読み込み完了を待たない）
  function loadSpreadsheetDirectly(location, queryType, deviceType = 'terminal') {
    if (DEBUG_MODE) {
      showDebugInfo('直接データ取得開始', { location, queryType, deviceType });
    }
    
    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');

    try {
      if (!google || !google.script || !google.script.run) {
        throw new Error('Google Apps Scriptの実行環境が正しく初期化されていません');
      }

      google.script.run
        .withSuccessHandler(function(response) {
          if (DEBUG_MODE) {
            showDebugInfo('直接データ取得成功', response);
          }
          loadingDiv.style.display = 'none';
          
          if (!response) {
            errorDiv.textContent = 'エラーが発生しました : スプレッドシート内の日時の表示形式を"書式なし"に変更してください';
            tableContainer.innerHTML = '';
            return;
          }
          
          if (response.success) {
            // 成功時はプリロードデータも更新
            if (typeof preloadedData !== 'undefined') {
              preloadedData[location] = response;
            }
            
            displayData(response.data, queryType);
            errorDiv.textContent = '';
            
            // 最終更新時刻を表示（拠点ごと）
            updateLastUpdateTime('lastUpdateTime', 'lastUpdateTimeText', location);
            
            // 読み込み完了メッセージを表示
            if (typeof showPopupMessage === 'function') {
              showPopupMessage('データを読み込みました');
            }
          } else {
            const errorMessage = response.error || '不明なエラーが発生しました';
            if (DEBUG_MODE) {
              showDebugInfo('直接データ取得エラー', { error: errorMessage });
            }
            errorDiv.textContent = 'エラー: ' + errorMessage;
            tableContainer.innerHTML = '';
          }

          if (response.logs && DEBUG_MODE) {
            showServerLogs(response.logs);
          }
        })
        .withFailureHandler(function(error) {
          if (DEBUG_MODE) {
            showDebugInfo('直接データ取得通信エラー', { error });
          }
          loadingDiv.style.display = 'none';
          errorDiv.textContent = 'エラーが発生しました: ' + error;
          tableContainer.innerHTML = '';
        })
        .getSpreadsheetData(location, queryType, deviceType);
    } catch (error) {
      if (DEBUG_MODE) {
        showDebugInfo('直接データ取得クライアントエラー', { error });
      }
      loadingDiv.style.display = 'none';
      errorDiv.textContent = 'クライアントサイドでエラーが発生しました: ' + error;
      tableContainer.innerHTML = '';
    }
  }

  // クエリタイプが変更されたときの処理
  function handleQueryChange() {
    if (currentLocation) {
      const queryType = document.querySelector('input[name="queryType"]:checked').value;
      const deviceTypeSelect = document.getElementById('deviceType');
      const selectedDeviceType = deviceTypeSelect ? deviceTypeSelect.value : 'terminal';
      loadSpreadsheet(currentLocation, queryType, selectedDeviceType);
    }
  }

  // スプレッドシートデータを読み込む
  function loadSpreadsheet(location, queryType, deviceType = 'terminal') {
    // プリロードされたデータがある場合はそれを使用
    if (typeof loadSpreadsheetWithPreload === 'function') {
      loadSpreadsheetWithPreload(location, queryType, deviceType);
      return;
    }
    
    // 以下は既存のロジック（プリロード機能がない場合のフォールバック）
    if (DEBUG_MODE) {
      showDebugInfo('データ取得開始（フォールバック）', { location, queryType });
    }
    
    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');

    loadingDiv.style.display = 'block';
    errorDiv.textContent = '';
    tableContainer.innerHTML = '';

    try {
      if (!google || !google.script || !google.script.run) {
        throw new Error('Google Apps Scriptの実行環境が正しく初期化されていません');
      }

      if (DEBUG_MODE) {
        showDebugInfo('getSpreadsheetData関数の呼び出し開始', { location, queryType });
      }
      google.script.run
        .withSuccessHandler(function(response) {
          if (DEBUG_MODE) {
            showDebugInfo('サーバーからの応答', response);
          }
          loadingDiv.style.display = 'none';
          
          if (!response) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = 'エラーが発生しました : スプレッドシート内の日時の表示形式を"書式なし"に変更してください';
            tableContainer.innerHTML = '';
            return;
          }
          
          if (response.success) {
            if (DEBUG_MODE) {
              showDebugInfo('データ表示開始', response.data);
            }
            displayData(response.data, queryType);
            errorDiv.textContent = '';
            
            // 最終更新時刻を表示（拠点ごと）
            updateLastUpdateTime('lastUpdateTime', 'lastUpdateTimeText', location);
          } else {
            const errorMessage = response.error || '不明なエラーが発生しました';
            const errorDetails = response.errorDetails || {};
            if (DEBUG_MODE) {
              showDebugInfo('エラー発生', { 
                error: errorMessage,
                details: errorDetails
              });
            }
            errorDiv.textContent = 'エラー: ' + errorMessage;
            tableContainer.innerHTML = '';
          }

          if (response.logs && DEBUG_MODE) {
            showServerLogs(response.logs);
          }
        })
        .withFailureHandler(function(error) {
          if (DEBUG_MODE) {
            showDebugInfo('サーバーエラー', { 
              error: error,
              errorType: typeof error,
              errorString: String(error),
              errorStack: error.stack
            });
          }
          loadingDiv.style.display = 'none';
          errorDiv.textContent = 'エラーが発生しました: ' + error;
          tableContainer.innerHTML = '';
        })
        .getSpreadsheetData(location, queryType, deviceType);
    } catch (error) {
      if (DEBUG_MODE) {
        showDebugInfo('クライアントサイドエラー', {
          error: error,
          errorType: typeof error,
          errorString: String(error),
          errorStack: error.stack
        });
      }
      loadingDiv.style.display = 'none';
      errorDiv.textContent = 'クライアントサイドでエラーが発生しました: ' + error;
      tableContainer.innerHTML = '';
    }
  }

  // データを表示する
  function displayData(data, queryType, dataType = 'main') {
    if (!data || data.length === 0) {
      showDebugInfo('データが空', {});
      const tableContainer = document.getElementById('tableContainer');
      tableContainer.innerHTML = '<p>データがありません</p>';
      return;
    }

    showDebugInfo('テーブル作成開始', { 
      rows: data.length, 
      columns: data[0].length,
      dataType: dataType 
    });

    // サマリーデータの場合は専用の表示関数を使用
    if (dataType === 'summary') {
      displaySummaryData(data);
      return;
    }

    // 新しいcreateTable関数を使用（dataTypeをdisplayModeに変換）
    const displayMode = dataType === 'audit' ? 'audit' : dataType === 'summary' ? 'summary' : 'main';
    createTable(data, queryType, '', displayMode);
    
    // フロート横スクロールバーの状態を更新（少し遅延して実行）
    setTimeout(() => {
      updateFloatScrollbarAfterTableLoad();
    }, 200);
  }

  // サマリーデータ専用の表示関数
  function displaySummaryData(data) {
    const tableContainer = document.getElementById('tableContainer');
    
    // サマリーデータの構造を分析
    const summaryHtml = createSummaryCards(data);
    
    if (!summaryHtml || summaryHtml.trim() === '') {
      // カードが生成されなかった場合のフォールバック表示
      tableContainer.innerHTML = `
        <div class="summary-container">
          <div class="summary-header">
            <h2>代替機状況サマリー</h2>
            <div class="summary-timestamp">
              最終更新: ${new Date().toLocaleString('ja-JP')}
            </div>
          </div>
          <div class="summary-fallback">
            <h3>データの解析中...</h3>
            <p>サマリーデータの構造を分析しています。しばらくお待ちください。</p>
            ${DEBUG_MODE ? `<pre class="debug-data">${JSON.stringify(data, null, 2)}</pre>` : ''}
          </div>
        </div>
      `;
      
      // デバッグ情報を表示
      if (DEBUG_MODE) {
        showDebugInfo('サマリーカード生成失敗', {
          dataLength: data.length,
          summaryHtmlEmpty: true
        });
      }
      return;
    }
    
    tableContainer.innerHTML = `
      <div class="summary-container">
        <div class="summary-header">
          <h2>代替機状況サマリー</h2>
          <div class="summary-timestamp">
            最終更新: ${new Date().toLocaleString('ja-JP')}
          </div>
        </div>
        ${summaryHtml}
      </div>
    `;
  }

  // サマリーカードを作成する関数
  function createSummaryCards(data) {
    let cardsHtml = '';
    let currentCategory = '';
    let currentCategoryData = [];
    
    // デバッグ: データ構造を確認
    if (DEBUG_MODE) {
      showDebugInfo('サマリーデータ構造確認', {
        totalRows: data.length,
        firstRow: data[0],
        secondRow: data[1],
        thirdRow: data[2]
      });
    }
    
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const firstCell = row[0] ? row[0].toString().trim() : '';
      const secondCell = row[1] ? row[1].toString().trim() : '';
      
      // カテゴリタイトルは2列目にあり、数字で始まる
      if (secondCell && secondCell.match(/^\d+\./)) {
        // 前のカテゴリが存在する場合、カードを作成
        if (currentCategory && currentCategoryData.length > 0) {
          cardsHtml += createSummaryCard(currentCategory, currentCategoryData);
        }
        
        // 新しいカテゴリを開始
        currentCategory = secondCell;
        currentCategoryData = [];
        
        if (DEBUG_MODE) {
          showDebugInfo('新しいカテゴリ発見', {
            category: currentCategory,
            row: i
          });
        }
      } else if (secondCell === 'SV') {
        // ヘッダー行をスキップ
        continue;
      } else if (firstCell === '大阪' || firstCell === '神戸' || firstCell === '姫路' || firstCell === '合計') {
        // データ行を追加
        currentCategoryData.push(row);
        
        if (DEBUG_MODE) {
          showDebugInfo('データ行追加', {
            location: firstCell,
            row: row,
            category: currentCategory
          });
        }
      }
    }
    
    // 最後のカテゴリを処理
    if (currentCategory && currentCategoryData.length > 0) {
      cardsHtml += createSummaryCard(currentCategory, currentCategoryData);
    }
    
    if (DEBUG_MODE) {
      showDebugInfo('サマリーカード生成完了', {
        generatedHtml: cardsHtml.length > 0,
        htmlLength: cardsHtml.length
      });
    }
    
    return cardsHtml;
  }

  // 個別のサマリーカードを作成
  function createSummaryCard(category, data) {
    // カテゴリのアイコンを決定
    const categoryIcon = getCategoryIcon(category);
    const categoryColor = getCategoryColor(category);
    
    let tableRows = '';
    let totalSV = 0, totalCL = 0, totalPrinter = 0, totalOther = 0;
    
    if (DEBUG_MODE) {
      showDebugInfo('カード作成中', {
        category: category,
        dataLength: data.length,
        data: data
      });
    }
    
    data.forEach((row, index) => {
      const location = row[0] || '';
      const sv = parseInt(row[1]) || 0;
      const cl = parseInt(row[2]) || 0;
      const printer = parseInt(row[3]) || 0;
      const other = parseInt(row[4]) || 0;
      
      if (DEBUG_MODE) {
        showDebugInfo('行処理中', {
          index: index,
          location: location,
          sv: sv,
          cl: cl,
          printer: printer,
          other: other
        });
      }
      
      if (location === '合計') {
        totalSV = sv;
        totalCL = cl;
        totalPrinter = printer;
        totalOther = other;
      } else {
        const total = sv + cl + printer + other;
        const hasData = total > 0;
        
        tableRows += `
          <tr class="${hasData ? 'has-data' : ''}">
            <td class="location-cell">
              <i class="fas fa-map-marker-alt"></i>
              ${location}
            </td>
            <td class="count-cell ${sv > 0 ? 'has-count' : ''}">${sv}</td>
            <td class="count-cell ${cl > 0 ? 'has-count' : ''}">${cl}</td>
            <td class="count-cell ${printer > 0 ? 'has-count' : ''}">${printer}</td>
            <td class="count-cell ${other > 0 ? 'has-count' : ''}">${other}</td>
            <td class="total-cell ${total > 0 ? 'has-total' : ''}">${total}</td>
          </tr>
        `;
      }
    });
    
    const grandTotal = totalSV + totalCL + totalPrinter + totalOther;
    
    if (DEBUG_MODE) {
      showDebugInfo('カード完成', {
        category: category,
        grandTotal: grandTotal,
        totalSV: totalSV,
        totalCL: totalCL,
        totalPrinter: totalPrinter,
        totalOther: totalOther
      });
    }
    
    return `
      <div class="summary-card" data-category="${categoryColor}">
        <div class="summary-card-header">
          <div class="summary-card-icon">
            <i class="${categoryIcon}"></i>
          </div>
          <h3 class="summary-card-title">${category}</h3>
          <div class="summary-card-total">
            合計: <span class="total-count">${grandTotal}</span>台
          </div>
        </div>
        <div class="summary-card-content">
          <table class="summary-table">
            <thead>
              <tr>
                <th>拠点</th>
                <th>SV</th>
                <th>CL</th>
                <th>プリンタ</th>
                <th>その他</th>
                <th>小計</th>
              </tr>
            </thead>
            <tbody>
              ${tableRows}
              <tr class="total-row">
                <td class="location-cell">
                  <i class="fas fa-calculator"></i>
                  <strong>合計</strong>
                </td>
                <td class="count-cell total-cell"><strong>${totalSV}</strong></td>
                <td class="count-cell total-cell"><strong>${totalCL}</strong></td>
                <td class="count-cell total-cell"><strong>${totalPrinter}</strong></td>
                <td class="count-cell total-cell"><strong>${totalOther}</strong></td>
                <td class="total-cell grand-total"><strong>${grandTotal}</strong></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    `;
  }

  // カテゴリアイコンを取得
  function getCategoryIcon(category) {
    if (category.includes('代替機を貸し出している')) return 'fas fa-tools';
    if (category.includes('商談や金額の問題')) return 'fas fa-exclamation-triangle';
    if (category.includes('代替機を貸し出し中だが')) return 'fas fa-user-times';
    if (category.includes('HW延長保守')) return 'fas fa-shield-alt';
    return 'fas fa-info-circle';
  }

  // カテゴリカラーを取得
  function getCategoryColor(category) {
    if (category.includes('代替機を貸し出している')) return 'info';
    if (category.includes('商談や金額の問題')) return 'warning';
    if (category.includes('代替機を貸し出し中だが')) return 'danger';
    if (category.includes('HW延長保守')) return 'success';
    return 'default';
  }

  // ステータス更新関数
  function updateStatus(rowIndex, newStatus) {
    showDebugInfo('ステータス更新開始', { rowIndex, newStatus });
    
    // 空文字列の場合はnullに変換
    const statusToUpdate = newStatus === '' ? null : newStatus;
    
    // ステータス変更の確認ダイアログ
    let label = '';
    switch (statusToUpdate) {
      case null:
      case '':
        label = '空欄'; break;
      case '1.返却可能':
        label = '1.返却可能'; break;
      case '2.商談/金銭的な理由により返却不可':
        label = '2.商談/金銭的な理由により返却不可'; break;
      case '3.お客様にて返却拒否':
        label = '3.お客様にて返却拒否'; break;
      case '4.HW延長保守にて貸出':
        label = '4.HW延長保守にて貸出'; break;
      default:
        label = statusToUpdate;
    }
    if (!window.confirm(`${label}に変更しますか？`)) {
      return;
    }
    
    const queryType = document.querySelector('input[name="queryType"]:checked')?.value || 'all';
    
    google.script.run
      .withSuccessHandler(function(response) {
        showDebugInfo('ステータス更新成功', response);
        if (response.success) {
          showPopupMessage('ステータスを更新しました');
          
          // プリロードデータをクリア（更新ボタンと同じ挙動）
          if (typeof preloadedData !== 'undefined' && preloadedData[currentLocation]) {
            delete preloadedData[currentLocation];
            showDebugInfo('ステータス更新後プリロードデータクリア', { location: currentLocation });
          }
          
          // 強制的に最新データを取得して表示（プリロードデータを使用しない）
          loadSpreadsheetForceRefresh(currentLocation, queryType);
          
        } else {
          // エラー時の処理
          const errorDiv = document.getElementById('error');
          errorDiv.textContent = 'ステータスの更新に失敗しました: ' + (response.error || '不明なエラー');
        }
      })
      .withFailureHandler(function(error) {
        showDebugInfo('ステータス更新エラー', { error });
        const errorDiv = document.getElementById('error');
        errorDiv.textContent = 'エラーが発生しました: ' + error;
      })
      .updateMachineStatus(rowIndex, statusToUpdate, currentLocation);
  }

  // 拠点ごとの最終更新時刻を記録するオブジェクト
  let locationUpdateTimes = {};

  // ページ読み込み時に拠点ごとの更新時刻を復元
  document.addEventListener('DOMContentLoaded', function() {
    loadLocationUpdateTimes();
  });

  // 拠点の更新時刻を記録する関数（表示は行わない）
  function recordLocationUpdateTime(location) {
    if (!location) return;
    
    const now = new Date();
    const timeString = now.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
    
    locationUpdateTimes[location] = timeString;
    // ローカルストレージにも保存
    try {
      localStorage.setItem('locationUpdateTimes', JSON.stringify(locationUpdateTimes));
    } catch (e) {
      console.warn('ローカルストレージへの保存に失敗しました:', e);
    }
  }

  // 最終更新時刻を更新する関数
  function updateLastUpdateTime(elementId, textElementId, location = null) {
    const now = new Date();
    const timeString = now.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
    
    // 拠点ごとの更新時刻を記録
    if (location) {
      locationUpdateTimes[location] = timeString;
      // ローカルストレージにも保存
      try {
        localStorage.setItem('locationUpdateTimes', JSON.stringify(locationUpdateTimes));
      } catch (e) {
        console.warn('ローカルストレージへの保存に失敗しました:', e);
      }
    }
    
    const element = document.getElementById(elementId);
    const textElement = document.getElementById(textElementId);
    
    if (element && textElement) {
      textElement.textContent = timeString;
      element.style.display = 'flex';
    }
  }

  // 拠点の最終更新時刻を取得する関数
  function getLocationUpdateTime(location) {
    return locationUpdateTimes[location] || null;
  }

  // ローカルストレージから拠点ごとの更新時刻を読み込む関数
  function loadLocationUpdateTimes() {
    try {
      const saved = localStorage.getItem('locationUpdateTimes');
      if (saved) {
        locationUpdateTimes = JSON.parse(saved);
        
        // デバッグ情報
        if (DEBUG_MODE && typeof showDebugInfo === 'function') {
          showDebugInfo('ローカルストレージから更新時刻復元', {
            count: Object.keys(locationUpdateTimes).length,
            times: locationUpdateTimes
          });
        }
      }
    } catch (e) {
      console.warn('ローカルストレージからの読み込みに失敗しました:', e);
      locationUpdateTimes = {};
    }
  }

  // 監査シート変更時に該当シートの最終更新時刻を表示する関数
  function displayAuditSheetUpdateTime(auditSheet) {
    const updateTime = getLocationUpdateTime(auditSheet);
    const element = document.getElementById('lastUpdateTimeAudit');
    const textElement = document.getElementById('lastUpdateTimeAuditText');
    const locationNameElement = document.getElementById('lastUpdateLocationNameAudit');
    
    // デバッグ情報
    if (DEBUG_MODE) {
      showDebugInfo('監査シート更新時刻表示', {
        auditSheet: auditSheet,
        updateTime: updateTime,
        allUpdateTimes: locationUpdateTimes,
        elementExists: !!element,
        textElementExists: !!textElement
      });
    }
    
    if (element && textElement) {
      if (updateTime) {
        textElement.textContent = updateTime;
        
        // 監査シート名を表示
        if (locationNameElement) {
          locationNameElement.textContent = `${auditSheet} `;
        }
        
        element.style.display = 'flex';
      } else {
        element.style.display = 'none';
      }
    }
  }

  // 拠点変更時に該当拠点の最終更新時刻を表示する関数
  function displayLocationUpdateTime(location) {
    const updateTime = getLocationUpdateTime(location);
    const element = document.getElementById('lastUpdateTime');
    const textElement = document.getElementById('lastUpdateTimeText');
    const locationNameElement = document.getElementById('lastUpdateLocationName');
    
    // デバッグ情報
    if (DEBUG_MODE) {
      showDebugInfo('拠点更新時刻表示', {
        location: location,
        updateTime: updateTime,
        allUpdateTimes: locationUpdateTimes,
        elementExists: !!element,
        textElementExists: !!textElement
      });
    }
    
    if (element && textElement) {
      if (updateTime) {
        textElement.textContent = updateTime;
        
        // 拠点名を表示（拠点マスタベース）
        if (locationNameElement) {
          const locationName = getLocationNameByIdSpreadsheet(location);
          locationNameElement.textContent = `${locationName} `;
        }
        
        element.style.display = 'flex';
      } else {
        element.style.display = 'none';
      }
    }
  }

  // 監査データを更新
  function refreshAuditData() {
    const auditSheet = document.getElementById('auditSheet').value;
    if (!auditSheet) {
      showPopupMessage('監査シートが選択されていません');
      return;
    }

    const refreshButton = document.getElementById('refreshAuditButton');
    
    // ボタンのローディング状態を設定
    if (refreshButton) {
      refreshButton.classList.add('loading');
      refreshButton.disabled = true;
    }

    showDebugInfo('監査データ手動更新開始', { auditSheet });
    
    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');

    loadingDiv.style.display = 'block';
    errorDiv.textContent = '';
    tableContainer.innerHTML = '';

    try {
      google.script.run
        .withSuccessHandler(function(response) {
          loadingDiv.style.display = 'none';
          
          // ボタンのローディング状態を解除
          if (refreshButton) {
            refreshButton.classList.remove('loading');
            refreshButton.disabled = false;
          }
          
          if (response.success) {
            // 監査データの場合、ヘッダー行を調整
            let adjustedData = response.data;
            if (response.metadata && response.metadata.isAuditData && response.metadata.headerRowIndex >= 0) {
              const headerRowIndex = response.metadata.headerRowIndex;
              if (headerRowIndex < response.data.length) {
                // ヘッダー行を先頭に移動
                const headerRow = response.data[headerRowIndex];
                const dataRows = response.data.slice(headerRowIndex + 1);
                adjustedData = [headerRow, ...dataRows];
                
                showDebugInfo('監査データのヘッダー行を調整（更新時）', {
                  originalHeaderRowIndex: headerRowIndex,
                  adjustedDataLength: adjustedData.length,
                  headerRow: headerRow
                });
              }
            }
            
            displayData(adjustedData, 'all', 'audit');
            errorDiv.textContent = '';
            showPopupMessage('監査データを更新しました');
            
            // 最終更新時刻を表示（監査シートごと）
            updateLastUpdateTime('lastUpdateTimeAudit', 'lastUpdateTimeAuditText', auditSheet);
            
            if (typeof showPopupMessage === 'function') {
              showPopupMessage(`${response.metadata.sheetType}を更新しました`);
            }
          } else {
            errorDiv.textContent = `監査データの取得に失敗しました: ${response.error}`;
            tableContainer.innerHTML = '';
          }
          
          if (response.logs && DEBUG_MODE) {
            showServerLogs(response.logs);
          }
        })
        .withFailureHandler(function(error) {
          loadingDiv.style.display = 'none';
          
          // ボタンのローディング状態を解除
          if (refreshButton) {
            refreshButton.classList.remove('loading');
            refreshButton.disabled = false;
          }
          
          errorDiv.textContent = `監査データの取得中にエラーが発生しました: ${error}`;
          tableContainer.innerHTML = '';
        })
        .getDestinationSheetData(auditSheet, 'all');
    } catch (error) {
      loadingDiv.style.display = 'none';
      
      // ボタンのローディング状態を解除
      if (refreshButton) {
        refreshButton.classList.remove('loading');
        refreshButton.disabled = false;
      }
      
      errorDiv.textContent = 'クライアントサイドでエラーが発生しました: ' + error;
      tableContainer.innerHTML = '';
    }
  }

  // サマリーデータを更新
  function refreshSummaryData() {
    const refreshButton = document.getElementById('refreshSummaryButton');
    
    // ボタンのローディング状態を設定
    if (refreshButton) {
      refreshButton.classList.add('loading');
      refreshButton.disabled = true;
    }

    showDebugInfo('サマリーデータ手動更新開始', {});
    
    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');

    loadingDiv.style.display = 'block';
    errorDiv.textContent = '';
    tableContainer.innerHTML = '';

    try {
      google.script.run
        .withSuccessHandler(function(response) {
          loadingDiv.style.display = 'none';
          
          // ボタンのローディング状態を解除
          if (refreshButton) {
            refreshButton.classList.remove('loading');
            refreshButton.disabled = false;
          }
          
          if (!response) {
            errorDiv.textContent = 'エラーが発生しました : スプレッドシート内の日時の表示形式を"書式なし"に変更してください';
            tableContainer.innerHTML = '';
            return;
          }
          
          if (response.success) {
            displayData(response.data, 'all', 'summary');
            errorDiv.textContent = '';
            showPopupMessage('サマリーデータを更新しました');
            
            // 最終更新時刻を表示
            updateLastUpdateTime('lastUpdateTimeSummary', 'lastUpdateTimeSummaryText');
          } else {
            const errorMessage = response.error || '不明なエラーが発生しました';
            errorDiv.textContent = `サマリーデータの取得に失敗しました: ${errorMessage}`;
            tableContainer.innerHTML = '';
          }
          
          if (response.logs && DEBUG_MODE) {
            showServerLogs(response.logs);
          }
        })
        .withFailureHandler(function(error) {
          loadingDiv.style.display = 'none';
          
          // ボタンのローディング状態を解除
          if (refreshButton) {
            refreshButton.classList.remove('loading');
            refreshButton.disabled = false;
          }
          
          errorDiv.textContent = `サマリーデータの取得中にエラーが発生しました: ${error}`;
          tableContainer.innerHTML = '';
        })
        .getDestinationSheetData('サマリー', 'all');
    } catch (error) {
      loadingDiv.style.display = 'none';
      
      // ボタンのローディング状態を解除
      if (refreshButton) {
        refreshButton.classList.remove('loading');
        refreshButton.disabled = false;
      }
      
      errorDiv.textContent = 'クライアントサイドでエラーが発生しました: ' + error;
      tableContainer.innerHTML = '';
    }
  }

  // 現在選択されている拠点のデータを更新
  function refreshCurrentLocation() {
    if (!currentLocation) {
      showPopupMessage('拠点が選択されていません');
      return;
    }

    const refreshButton = document.getElementById('refreshButton');
    const queryType = document.querySelector('input[name="queryType"]:checked')?.value || 'all';
    const deviceTypeSelect = document.getElementById('deviceType');
    const selectedDeviceType = deviceTypeSelect ? deviceTypeSelect.value : 'terminal';
    
    // ボタンのローディング状態を設定
    if (refreshButton) {
      refreshButton.classList.add('loading');
      refreshButton.disabled = true;
    }

    showDebugInfo('手動更新開始', { location: currentLocation, queryType });
    
    // プリロードデータをクリア（強制的に最新データを取得）
    if (preloadedData && preloadedData[currentLocation]) {
      delete preloadedData[currentLocation];
      showDebugInfo('プリロードデータをクリア', { location: currentLocation });
    }

    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');

    loadingDiv.style.display = 'block';
    errorDiv.textContent = '';
    tableContainer.innerHTML = '';

    try {
      if (!google || !google.script || !google.script.run) {
        throw new Error('Google Apps Scriptの実行環境が正しく初期化されていません');
      }

      showDebugInfo('最新データ取得開始', { location: currentLocation, queryType });
      google.script.run
        .withSuccessHandler(function(response) {
          showDebugInfo('更新データ取得成功', response);
          loadingDiv.style.display = 'none';
          
          // ボタンのローディング状態を解除
          if (refreshButton) {
            refreshButton.classList.remove('loading');
            refreshButton.disabled = false;
          }
          
          if (!response) {
            errorDiv.textContent = 'エラーが発生しました : スプレッドシート内の日時の表示形式を"書式なし"に変更してください';
            tableContainer.innerHTML = '';
            return;
          }
          
          if (response.success) {
            // プリロードデータも更新
            if (typeof preloadedData !== 'undefined') {
              preloadedData[currentLocation] = response;
            }
            
            showDebugInfo('最新データ表示開始', response.data);
            displayData(response.data, queryType);
            errorDiv.textContent = '';
            showPopupMessage('データを更新しました');
            
            // 最終更新時刻を表示（拠点ごと）
            updateLastUpdateTime('lastUpdateTime', 'lastUpdateTimeText', currentLocation);
          } else {
            const errorMessage = response.error || '不明なエラーが発生しました';
            showDebugInfo('更新エラー発生', { error: errorMessage });
            errorDiv.textContent = 'エラー: ' + errorMessage;
            tableContainer.innerHTML = '';
          }

          if (response.logs) {
            showServerLogs(response.logs);
          }
        })
        .withFailureHandler(function(error) {
          showDebugInfo('更新通信エラー', { error });
          loadingDiv.style.display = 'none';
          
          // ボタンのローディング状態を解除
          if (refreshButton) {
            refreshButton.classList.remove('loading');
            refreshButton.disabled = false;
          }
          
          errorDiv.textContent = 'エラーが発生しました: ' + error;
          tableContainer.innerHTML = '';
        })
        .getSpreadsheetData(currentLocation, queryType, selectedDeviceType);
    } catch (error) {
      showDebugInfo('更新処理エラー', { error });
      loadingDiv.style.display = 'none';
      
      // ボタンのローディング状態を解除
      if (refreshButton) {
        refreshButton.classList.remove('loading');
        refreshButton.disabled = false;
      }
      
      errorDiv.textContent = 'クライアントサイドでエラーが発生しました: ' + error;
      tableContainer.innerHTML = '';
    }
  }

  // 拠点管理番号の列インデックスを推定する関数
  function findLocationCodeColumnIndex(headers) {
    // 一般的な拠点管理番号列名のパターンを検索
    const locationColumnNames = ['拠点管理番号', '拠点コード', '拠点', 'location', 'site_code'];
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i].toString().toLowerCase();
      for (const pattern of locationColumnNames) {
        if (header.includes(pattern.toLowerCase())) {
          return i;
        }
      }
    }
    return -1; // 見つからない場合
  }

  // ヘッダー名から列インデックスを取得する汎用関数
  function findColumnIndex(headers, patterns) {
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i].toString().toLowerCase();
      for (const pattern of patterns) {
        if (header.includes(pattern.toLowerCase())) {
          return i;
        }
      }
    }
    return -1; // 見つからない場合
  }

  // 預りユーザー機のシリアルNo.列インデックスを取得
  function findUserMachineSerialColumnIndex(headers) {
    const patterns = [
      '1-8.預りユーザー機のシリアルno.(製造番号)',
      '1-6.預りユーザー機のシリアルno.(製造番号)',
      '預りユーザー機のシリアルno',
      '預りユーザー機のシリアル',
      '預りユーザー機',
      'シリアルno',
      'シリアル番号',
      '製造番号',
      'ユーザー機シリアル',
      '預り機シリアル'
    ];
    return findColumnIndex(headers, patterns);
  }

  // ユーザー機の預り有無列インデックスを取得
  function findUserMachineDepositColumnIndex(headers) {
    const patterns = [
      '1-4.ユーザー機の預り有無',
    ];
    return findColumnIndex(headers, patterns);
  }

  // 新しい貸出中(ユーザー預り機有)の判定関数
  function isLendingWithUserMachine(data, rowIndex, headers) {
    const serialColumnIndex = findUserMachineSerialColumnIndex(headers);
    
    // デバッグ情報
    if (DEBUG_MODE && rowIndex === 1) { // 最初のデータ行でのみログ出力
      showDebugInfo('貸出中(ユーザー預り機有)判定列情報', {
        serialColumnIndex: serialColumnIndex,
        serialHeader: serialColumnIndex !== -1 ? headers[serialColumnIndex] : 'なし'
      });
    }
    
    // 預りユーザー機のシリアルNo.(製造番号)列に内容が存在している
    const hasSerial = serialColumnIndex !== -1 && 
                     data[rowIndex][serialColumnIndex] && 
                     data[rowIndex][serialColumnIndex].toString().trim() !== '';
    
    // デバッグ情報（最初の数行のみ）
    if (DEBUG_MODE && rowIndex <= 5) {
      showDebugInfo(`行${rowIndex}の貸出中判定`, {
        hasSerial: hasSerial,
        result: hasSerial,
        serialValue: serialColumnIndex !== -1 ? data[rowIndex][serialColumnIndex] : 'N/A'
      });
    }
    
    return hasSerial;
  }

  // 既存の貸出中判定も維持（フォールバック）
  function isLendingWithUserMachineLegacy(data, rowIndex, currentLocation) {
    // プリンタロケーションの場合はC列、それ以外はD列の"貸出"をチェック
    const isLending = (currentLocation === 'osaka_printer' || currentLocation === 'hyogo_printer') ?
      (data[rowIndex][2] && data[rowIndex][2].includes('貸出')) :
      (data[rowIndex][3] && data[rowIndex][3].includes('貸出'));

    // プリンタロケーションの場合は10列目のチェックを除外
    const shouldShowDropdown = (currentLocation === 'osaka_printer' || currentLocation === 'hyogo_printer') ?
      isLending :
      (isLending && data[rowIndex][9]);
    
    return shouldShowDropdown;
  }

  // 代替機フォーム回答シートのデータを読み込む
  function loadLocationSheet(locationCode) {
    if (!currentLocation) {
      showPopupMessage('拠点が選択されていません');
      return;
    }

    // 現在の代替機フォーム回答シート名を保存
    currentLocationSheetName = locationCode;
    
    // 表示制御変数をリセット
    locationSheetDisplayCount = 10;
    locationSheetAllData = null;
    locationSheetCurrentData = null;

    showDebugInfo('代替機フォーム回答シート読み込み開始', { currentLocation, locationCode });

    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');

    loadingDiv.style.display = 'block';
    errorDiv.textContent = '';
    tableContainer.innerHTML = '';

    google.script.run
      .withSuccessHandler(function(response) {
        loadingDiv.style.display = 'none';
        
        if (response.success) {
          showDebugInfo('代替機フォーム回答シート読み込み成功', response);
          
          // 全データを保存
          locationSheetAllData = response.data;
          
          // データをタイムスタンプでソートして最新10件を表示
          displayLocationSheetData(locationCode);
          
        } else {
          errorDiv.textContent = `代替機フォーム回答シート「${locationCode}」の読み込みに失敗しました: ${response.error}`;
          showDebugInfo('代替機フォーム回答シート読み込みエラー', response);
        }
      })
      .withFailureHandler(function(error) {
        loadingDiv.style.display = 'none';
        errorDiv.textContent = `代替機フォーム回答シート「${locationCode}」の読み込み中にエラーが発生しました: ${error}`;
        showDebugInfo('代替機フォーム回答シート読み込み通信エラー', { error });
      })
      .getLocationSheetData(currentLocation, locationCode, 'all');
  }

  // 代替機フォーム回答シートのデータをソート・制限して表示
  function displayLocationSheetData(locationCode) {
    if (!locationSheetAllData || locationSheetAllData.length <= 1) {
      showDebugInfo('代替機フォーム回答シートデータが空', {});
      const tableContainer = document.getElementById('tableContainer');
      tableContainer.innerHTML = `
        <div class="sheet-navigation">
          <button onclick="backToMainView()" class="back-button">
            <i class="fas fa-arrow-left"></i>
            一覧に戻る
          </button>
          <h3>代替機フォーム回答シート: ${locationCode}</h3>
        </div>
        <div class="no-data-message">
          <i class="fas fa-info-circle"></i>
          <p>データがありません</p>
        </div>
      `;
      return;
    }
    
    // タイムスタンプ列を検索（一般的なタイムスタンプ列名）
    const headers = locationSheetAllData[0];
    let timestampColumnIndex = -1;
    const timestampPatterns = ['タイムスタンプ', 'timestamp', '作成日時', '更新日時', '日時'];
    
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i].toString().toLowerCase();
      for (const pattern of timestampPatterns) {
        if (header.includes(pattern.toLowerCase())) {
          timestampColumnIndex = i;
          break;
        }
      }
      if (timestampColumnIndex !== -1) break;
    }
    
    showDebugInfo('タイムスタンプ列検出', { timestampColumnIndex, headers });
    
    // データ行をコピーしてソート
    const dataRows = locationSheetAllData.slice(1); // ヘッダー以外をコピー
    
    if (timestampColumnIndex !== -1) {
      // タイムスタンプでソート（新しい順）
      dataRows.sort((a, b) => {
        const timestampA = new Date(a[timestampColumnIndex] || 0);
        const timestampB = new Date(b[timestampColumnIndex] || 0);
        return timestampB - timestampA; // 降順（新しい順）
      });
    }
    
    // 表示件数を制限
    const displayRows = dataRows.slice(0, locationSheetDisplayCount);
    locationSheetCurrentData = [headers, ...displayRows];
    
    // 戻るボタンとタイトルを作成
    let navigationHtml = `
      <div class="sheet-navigation">
        <button onclick="backToMainView()" class="back-button">
          <i class="fas fa-arrow-left"></i>
          一覧に戻る
        </button>
        <h3>代替機フォーム回答シート: ${locationCode}</h3>
        <div class="sheet-info">
          表示中: ${displayRows.length}件 / 全体: ${dataRows.length}件
        </div>
      </div>
    `;
    
    // 最新エントリー情報を追加
    if (dataRows.length > 0) {
      const latestRow = dataRows[0];
      navigationHtml += createLatestEntryCard(headers, latestRow, timestampColumnIndex);
    }
    
    // 追加読み込みボタンを追加（10件以上ある場合）
    if (dataRows.length > locationSheetDisplayCount) {
      navigationHtml += `
        <div class="load-more-container">
          <button onclick="loadMoreLocationSheetData()" class="load-more-button">
            <i class="fas fa-plus"></i>
            さらに${Math.min(10, dataRows.length - locationSheetDisplayCount)}件を読み込む
          </button>
        </div>
      `;
    }
    
    // 代替機フォーム回答シート表示モードでcreateTableを呼び出し
    createTable(locationSheetCurrentData, 'all', navigationHtml, 'location-sheet');
    
    showDebugInfo('代替機フォーム回答シート表示完了', {
      totalRows: dataRows.length,
      displayedRows: displayRows.length,
      timestampColumn: timestampColumnIndex
    });
  }

  // 最新エントリーカードを作成
  function createLatestEntryCard(headers, latestRow, timestampColumnIndex) {
    // ステータス列を検索
    let statusColumnIndex = -1;
    const statusPatterns = ['ステータス', 'status', '状態', '現在の状態'];
    
    for (let i = 0; i < headers.length; i++) {
      const header = headers[i].toString().toLowerCase();
      for (const pattern of statusPatterns) {
        if (header.includes(pattern.toLowerCase())) {
          statusColumnIndex = i;
          break;
        }
      }
      if (statusColumnIndex !== -1) break;
    }
    
    // 表示する情報を準備
    const displayItems = [];
    
    // タイムスタンプ
    if (timestampColumnIndex !== -1 && latestRow[timestampColumnIndex]) {
      let timestampValue = latestRow[timestampColumnIndex].toString();
      try {
        const date = new Date(timestampValue);
        if (!isNaN(date.getTime())) {
          timestampValue = date.toLocaleString('ja-JP', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
          });
        }
      } catch (e) {
        // フォーマットに失敗した場合はそのまま使用
      }
      
      displayItems.push({
        label: '最終更新',
        value: timestampValue,
        type: 'timestamp'
      });
    }
    
    // ステータス
    if (statusColumnIndex !== -1 && latestRow[statusColumnIndex]) {
      displayItems.push({
        label: 'ステータス',
        value: latestRow[statusColumnIndex].toString(),
        type: 'status'
      });
    }
    
    // 情報がない場合はカードを表示しない
    if (displayItems.length === 0) {
      return '';
    }
    
    // フォーマルなカードHTML生成
    let cardHtml = `
      <div class="current-status-card">
        <div class="status-card-header">
          <div class="status-card-icon">
            <i class="fas fa-info-circle"></i>
          </div>
          <h4>現在のステータス</h4>
        </div>
        <div class="status-card-content">
    `;
    
    // データ項目を表示
    displayItems.forEach((item) => {
      cardHtml += `
        <div class="status-card-item">
          <span class="status-label">${item.label}</span>
          <span class="status-value ${item.type === 'timestamp' ? 'timestamp-value' : 'status-value'}">${item.value}</span>
        </div>
      `;
    });
    
    cardHtml += `
        </div>
      </div>
    `;
    
    return cardHtml;
  }

  // 一覧画面に戻る
  function backToMainView() {
    // 代替機フォーム回答シート名をクリア
    currentLocationSheetName = null;
    
    // 表示制御変数をリセット
    locationSheetDisplayCount = 10;
    locationSheetAllData = null;
    locationSheetCurrentData = null;
    
    const queryType = document.querySelector('input[name="queryType"]:checked')?.value || 'all';
    loadSpreadsheet(currentLocation, queryType);
  }

  // 代替機フォーム回答シートの追加データを読み込む
  function loadMoreLocationSheetData() {
    if (!currentLocationSheetName || !locationSheetAllData) {
      showPopupMessage('データが見つかりません');
      return;
    }
    
    // 表示件数を増やす
    locationSheetDisplayCount += 10;
    
    showDebugInfo('追加データ読み込み', { 
      displayCount: locationSheetDisplayCount,
      locationSheet: currentLocationSheetName 
    });
    
    // データを再表示
    displayLocationSheetData(currentLocationSheetName);
  }

  // 動的列幅調整関数
  function adjustColumnWidths(data, displayMode = 'main') {
    if (!data || data.length === 0) return;
    
    // 各列の最大文字数を計算
    const columnWidths = [];
    const minWidth = 60;  // 最小幅
    const maxWidth = 400; // 最大幅
    const charWidthFactor = 8; // 1文字あたりのピクセル数（目安）
    
    // ヘッダー行を含む全データをチェック
    for (let colIndex = 0; colIndex < data[0].length; colIndex++) {
      let maxLength = 0;
      
      // ヘッダー行の文字数をチェック
      const headerText = data[0][colIndex]?.toString() || '';
      maxLength = Math.max(maxLength, headerText.length);
      
      // データ行の文字数をチェック
      for (let rowIndex = 1; rowIndex < data.length; rowIndex++) {
        const cellText = data[rowIndex][colIndex]?.toString() || '';
        maxLength = Math.max(maxLength, cellText.length);
      }
      
      // 文字数から推定幅を計算（最小値・最大値の制限あり）
      let estimatedWidth = Math.max(minWidth, maxLength * charWidthFactor);
      estimatedWidth = Math.min(maxWidth, estimatedWidth);
      
      // 特別な調整
      if (colIndex === 0 && displayMode === 'main') {
        // 項番列は固定幅
        estimatedWidth = 60;
      } else if (colIndex === 0) {
        // A列（ステータス列など）
        estimatedWidth = Math.max(120, estimatedWidth);
      }
      
      columnWidths.push(estimatedWidth);
    }
    
    showDebugInfo('動的列幅計算結果', { columnWidths });
    
    // CSSスタイルを動的に適用
    const table = document.querySelector('#tableContainer table');
    if (table) {
      // 項番列がある場合の調整
      let columnOffset = displayMode === 'main' ? 1 : 0;
      
      // ヘッダー行に幅を適用
      const headerCells = table.querySelectorAll('th');
      headerCells.forEach((th, index) => {
        if (index === 0 && displayMode === 'main') {
          // 項番列
          th.style.width = '60px';
          th.style.minWidth = '60px';
        } else {
          // データ列
          const dataColumnIndex = index - columnOffset;
          if (dataColumnIndex >= 0 && dataColumnIndex < columnWidths.length) {
            th.style.width = columnWidths[dataColumnIndex] + 'px';
            th.style.minWidth = columnWidths[dataColumnIndex] + 'px';
          }
        }
      });
      
      // データ行に幅を適用
      const dataCells = table.querySelectorAll('td');
      dataCells.forEach((td, index) => {
        const columnIndex = index % headerCells.length;
        if (columnIndex === 0 && displayMode === 'main') {
          // 項番列
          td.style.width = '60px';
          td.style.minWidth = '60px';
        } else {
          // データ列
          const dataColumnIndex = columnIndex - columnOffset;
          if (dataColumnIndex >= 0 && dataColumnIndex < columnWidths.length) {
            td.style.width = columnWidths[dataColumnIndex] + 'px';
            td.style.minWidth = columnWidths[dataColumnIndex] + 'px';
          }
        }
      });
    }
  }

  // データからサンプルステータス値を取得
  function getSampleStatusValue(data, columnIndex) {
    // 最初の非空データを返す
    for (let i = 1; i < data.length && i < 10; i++) { // 最初の10行をチェック
      if (data[i][columnIndex] && data[i][columnIndex].toString().trim() !== '') {
        return data[i][columnIndex].toString().trim();
      }
    }
    return null;
  }
  
  // 列を表示すべきか判定
  function shouldShowColumn(columnHeader, statusPrefix, nestedStatusPrefix) {
    if (!columnHeader) return true;
    
    const headerStr = columnHeader.toString();
    
    // 基本列は常に表示
    const baseColumns = [
      '拠点管理番号',
      '機器種別',
      '機種名',
      '製造番号',
      'タイムスタンプ',
      '0-1.担当者',
      '0-4.ステータス',
      '更新日時',
      '更新日',
      '作成日'
    ];
    
    // 基本列は常に表示
    for (const baseCol of baseColumns) {
      if (headerStr.includes(baseCol)) {
        return true;
      }
    }
    
    // 数字-数字.パターンの列をチェック
    const match = headerStr.match(/^(\d+)-(\d+)\./); 
    if (match) {
      const prefix = match[1];
      const subPrefix = match[2];
      
      // ステータスの接頭辞と一致するかチェック
      if (prefix !== statusPrefix) {
        return false;
      }
      
      // 3.社内にて保管中の場合のネスト処理
      if (statusPrefix === '3' && nestedStatusPrefix && subPrefix !== '0') {
        // 3-0.社内ステータスは常に表示
        // 3-X-パターンはネストステータスが一致する場合のみ表示
        return subPrefix === nestedStatusPrefix;
      }
      
      return true;
    }
    
    // その他の列は表示
    return true;
  }

  function createTable(data, queryType, prependContent = '', displayMode = 'main') {
    const tableContainer = document.getElementById('tableContainer');
    
    // 拠点管理番号の列インデックスを取得
    const locationCodeColumnIndex = findLocationCodeColumnIndex(data[0]);
    
    // ステータス駆動型列フィルタリングのための処理
    let statusPrefixFilter = null;
    let nestedStatusFilter = null;
    
    // 通常データ（NORMAL）の場合のみステータス駆動型フィルタリングを適用
    const dataTypeId = document.getElementById('dataType') ? document.getElementById('dataType').value : '';
    if (dataTypeId === 'NORMAL' && displayMode === 'main') {
      // 0-4.ステータス列を探す
      const statusColumnIndex = data[0].findIndex(header => header && header.includes('0-4.ステータス'));
      
      if (statusColumnIndex !== -1 && data.length > 1) {
        // データの中からステータス値を取得（代表的な値を使用）
        const sampleStatusValue = getSampleStatusValue(data, statusColumnIndex);
        
        if (sampleStatusValue) {
          // ステータスの接頭辞数字を抽出
          const match = sampleStatusValue.match(/^(\d+)\./); 
          if (match) {
            statusPrefixFilter = match[1];
            
            if (DEBUG_MODE) {
              showDebugInfo('ステータス駆動型フィルタリング適用', {
                statusColumnIndex,
                sampleStatusValue,
                statusPrefixFilter,
                dataTypeId
              });
            }
            
            // 3.社内にて保管中の場合、ネストしたステータスを確認
            if (statusPrefixFilter === '3') {
              const nestedStatusColumnIndex = data[0].findIndex(header => header && header.includes('3-0.社内ステータス'));
              
              if (nestedStatusColumnIndex !== -1) {
                const sampleNestedStatusValue = getSampleStatusValue(data, nestedStatusColumnIndex);
                if (sampleNestedStatusValue) {
                  const nestedMatch = sampleNestedStatusValue.match(/^(\d+)\./); 
                  if (nestedMatch) {
                    nestedStatusFilter = nestedMatch[1];
                    
                    if (DEBUG_MODE) {
                      showDebugInfo('ネストステータスフィルタリング適用', {
                        nestedStatusColumnIndex,
                        sampleNestedStatusValue,
                        nestedStatusFilter
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    
    // 空の列をチェックする関数
    function isColumnEmpty(columnIndex) {
      // 代替機フォーム回答シート表示モードの場合は空列チェックを無効化
      if (displayMode === 'location-sheet') {
        return false;
      }
      
      // A列（ステータス列）は空でも表示する
      if (columnIndex === 0) {
        return false;
      }
      
      for (let i = 1; i < data.length; i++) {
        // クエリタイプに応じてフィルタリング
        if (queryType === 'all' || 
            (queryType === 'lending' && isLendingWithUserMachine(data, i, data[0]))) {
          if (data[i][columnIndex] && data[i][columnIndex].toString().trim() !== '') {
            return false;
          }
        }
      }
      return true;
    }

    // 貸出中フィルタリング時のデータ存在チェック
    let hasLendingData = false;
    if (queryType === 'lending') {
      for (let i = 1; i < data.length; i++) {
        if (isLendingWithUserMachine(data, i, data[0])) {
          hasLendingData = true;
          break;
        }
      }
      
      // 貸出中データがない場合
      if (!hasLendingData) {
        showDebugInfo('貸出中データなし（新条件）', {});
        tableContainer.innerHTML = prependContent + `
          <div class="no-data-message">
            <i class="fas fa-info-circle"></i>
            <p>貸出中（ユーザー預り機有）のデータはありません</p>
            <p style="font-size: 0.9em; color: var(--text-secondary); margin-top: 8px;">
              条件：「預りユーザー機のシリアルNo.」に内容がある または「ユーザー機の預り有無」が「有り」
            </p>
          </div>
        `;
        return;
      }
    }

    // 空の列をログに記録
    const emptyColumns = [];
    for (let i = 0; i < data[0].length; i++) {
      if (isColumnEmpty(i)) {
        emptyColumns.push({ index: i, header: data[0][i] || '(空)' });
      }
    }
    showDebugInfo('空の列を検出', { emptyColumns });

    // データ統計を計算
    const totalRows = data.length - 1; // ヘッダーを除外
    let displayedRows = 0;
    let lendingRows = 0;
    let userKeepingRows = 0; // 預り台数（ユーザー預り機有）
    
    // ステータス列のインデックスを特定
    let statusColumnIndex = -1;
    if (currentLocation === 'osaka_printer' || currentLocation === 'hyogo_printer') {
      statusColumnIndex = 2; // プリンタの場合はC列（インデックス2）
    } else {
      statusColumnIndex = 3; // プリンタ以外の場合はD列（インデックス3）
    }
    
    for (let i = 1; i < data.length; i++) {
      // 新しい貸出中(ユーザー預り機有)の判定
      const isLendingWithUser = isLendingWithUserMachine(data, i, data[0]);
      
      // 貸出中の判定（ステータス列に「貸出」が含まれていればカウント）
      const isLending = data[i][statusColumnIndex] && 
                       data[i][statusColumnIndex].toString().includes('貸出');
      
      // 預り台数の判定（新しい条件でカウント）
      const isUserKeeping = isLendingWithUserMachine(data, i, data[0]);
      
      if (isLending) {
        lendingRows++;
      }
      
      if (isUserKeeping) {
        userKeepingRows++;
      }
      
      // 表示されるデータをカウント（新しいロジックを使用）
      if (queryType === 'all' || (queryType === 'lending' && isLendingWithUser)) {
        displayedRows++;
      }
    }

    // メインモードの場合はデータステータス情報を追加
    let statusInfoHtml = '';
    if (displayMode === 'main') {
      statusInfoHtml = createDataStatusPanel(totalRows, displayedRows, lendingRows, userKeepingRows, queryType);
      
      // デバッグ情報を追加
      showDebugInfo('データ統計計算完了', {
        totalRows,
        displayedRows,
        lendingRows,
        userKeepingRows,
        queryType,
        statusColumnIndex,
        location: currentLocation,
        serialColumnIndex: findUserMachineSerialColumnIndex(data[0]),
        newCondition: '「預りユーザー機のシリアルNo.」に内容がある（ユーザー機の預り有無条件は除外）'
      });
    }

    let table = '<table>';
    
    // ヘッダー行
    table += '<tr>';
    // メインモードの場合のみ項番列を追加
    if (displayMode === 'main') {
    table += '<th>#</th>'; // 項番列を追加
    }
    
    data[0].forEach((cell, index) => {
      // *** デバッグ：A列の処理状況を出力 ***
      if (DEBUG_MODE && index === 0) {
        showDebugInfo('ヘッダーA列処理', {
          index: index,
          queryType: queryType,
          displayMode: displayMode,
          cellValue: cell,
          shouldSkip: (index === 0 && queryType === 'all' && displayMode === 'main'),
          isEmpty: isColumnEmpty(index)
        });
      }
      
      // 一覧表示の場合はA列を非表示、貸出中(ユーザー預り機有)の場合はA列を表示
      if (index === 0 && queryType === 'all' && displayMode === 'main') {
        return;
      }
      
      // 空の列は表示しない（代替機フォーム回答シートモードでは全て表示）
      if (isColumnEmpty(index)) {
        return;
      }
      
      // ステータス駆動型フィルタリング
      if (statusPrefixFilter && !shouldShowColumn(cell, statusPrefixFilter, nestedStatusFilter)) {
        return;
      }
      
      table += `<th>${cell}</th>`;
    });
    table += '</tr>';

    // データ行
    let rowNumber = 1; // 項番用のカウンター
    for (let i = 1; i < data.length; i++) {
      // クエリタイプに応じて表示する行をフィルタリング（新しい条件を使用）
      if (queryType === 'all' || 
          (queryType === 'lending' && isLendingWithUserMachine(data, i, data[0]))) {
        
        // 代替機フォーム回答シートの場合、最新行（1行目のデータ）を強調
        const isLatestRow = (displayMode === 'location-sheet' && i === 1);
        const rowClass = isLatestRow ? ' class="latest-row"' : '';
        
        table += `<tr${rowClass}>`;
        
        // メインモードの場合のみ項番を追加
        if (displayMode === 'main') {
        table += `<td>${rowNumber}</td>`; // 項番を追加
        }
        rowNumber++; // 項番をインクリメント
        
        data[i].forEach((cell, index) => {
          // *** デバッグ：A列の処理状況を出力 ***
          if (DEBUG_MODE && index === 0) {
            showDebugInfo('ヘッダーA列処理', {
              index: index,
              queryType: queryType,
              displayMode: displayMode,
              cellValue: cell,
              shouldSkip: (index === 0 && queryType === 'all' && displayMode === 'main'),
              isEmpty: isColumnEmpty(index)
            });
          }
          
          // 一覧表示の場合はA列を非表示、貸出中(ユーザー預り機有)の場合はA列を表示
          if (index === 0 && queryType === 'all' && displayMode === 'main') {
            return;
          }
          
          // 空の列は表示しない（代替機フォーム回答シートモードでは全て表示）
          if (isColumnEmpty(index)) {
            return;
          }
          
          // ステータス駆動型フィルタリング
          if (statusPrefixFilter && !shouldShowColumn(data[0][index], statusPrefixFilter, nestedStatusFilter)) {
            return;
          }
          
          if (index === 0 && displayMode === 'main') {
            // 貸出中(ユーザー預り機有)モードの場合は常にプルダウンを表示
            let shouldShowDropdown = false;
            
            if (queryType === 'lending') {
              // 貸出中(ユーザー預り機有)モードでは常にプルダウン表示
              shouldShowDropdown = true;
              
              if (DEBUG_MODE && i <= 3) {
                showDebugInfo(`行${i}貸出中モードプルダウン表示`, {
                  queryType: queryType,
                  forcedDropdown: true,
                  cellValue: cell || 'なし'
                });
              }
            } else {
              // 一覧モードの場合は従来の条件で判定
              shouldShowDropdown = isLendingWithUserMachine(data, i, data[0]);
              
              // 新しい条件で判定できない場合は既存のロジックをフォールバックとして使用
              if (!shouldShowDropdown) {
                shouldShowDropdown = isLendingWithUserMachineLegacy(data, i, currentLocation);
              }
              
              if (DEBUG_MODE && i <= 3) {
                showDebugInfo(`行${i}一覧モードプルダウン判定`, {
                  queryType: queryType,
                  shouldShowDropdown: shouldShowDropdown,
                  cellValue: cell || 'なし'
                });
              }
            }

            if (!shouldShowDropdown) {
              table += `<td>${cell || ''}</td>`;
            } else {
              const currentValue = cell || '';
              table += `<td>
                <select onchange="updateStatus(${i}, this.value)" class="status-select">
                  <option value="" ${currentValue === '' ? 'selected' : ''}></option>
                  <option value="1.返却可能" ${currentValue === '1.返却可能' ? 'selected' : ''}>1.返却可能</option>
                  <option value="2.商談/金銭的な理由により返却不可" ${currentValue === '2.商談/金銭的な理由により返却不可' ? 'selected' : ''}>2.商談/金銭的な理由により返却不可</option>
                  <option value="3.お客様にて返却拒否" ${currentValue === '3.お客様にて返却拒否' ? 'selected' : ''}>3.お客様にて返却拒否</option>
                  <option value="4.HW延長保守にて貸出" ${currentValue === '4.HW延長保守にて貸出' ? 'selected' : ''}>4.HW延長保守にて貸出</option>
                </select>
              </td>`;
            }
          } else if (index === locationCodeColumnIndex && locationCodeColumnIndex !== -1 && displayMode === 'main') {
            // 拠点管理番号列をクリック可能にする（メインモードのみ）
            const cellValue = cell || '';
            if (cellValue.toString().trim() !== '') {
              table += `<td><a href="#" onclick="loadLocationSheet('${cellValue}'); return false;" class="location-link">${cellValue}</a></td>`;
            } else {
              table += `<td>${cellValue}</td>`;
            }
          } else {
            table += `<td>${cell || ''}</td>`;
          }
        });
        table += '</tr>';
      }
    }

    table += '</table>';
    tableContainer.innerHTML = prependContent + statusInfoHtml + table;
    
    // 代替機フォーム回答シート表示時のみセルクリック編集機能を有効化
    // mainシートは数式でデータを取得するため編集不可
    if (displayMode === 'location-sheet') {
      enableCellEditing(data);
    }
    
    // ドラッグ&ドロップ機能を有効化
    setupColumnDragAndDrop();
    
    // 動的列幅調整を実行
    setTimeout(() => {
      adjustColumnWidths(data, displayMode);
      
      // フロート横スクロールバーの状態を更新
      updateFloatScrollbarAfterTableLoad();
    }, 100); // DOM更新後に実行
    
    showDebugInfo('テーブル作成完了', { 
      displayMode,
      statusPrefixFilter,
      nestedStatusFilter,
      dataTypeId,
      filteredColumns: statusPrefixFilter ? 'ステータス駆動型フィルタリング適用' : 'フィルタリングなし'
    });
  }

  // データステータスパネルを作成（一覧画面用）
  function createDataStatusPanel(totalRows, displayedRows, lendingRows, userKeepingRows, queryType) {
    const locationName = currentLocation ? 
      getLocationNameByIdSpreadsheet(currentLocation) : '未選択';
    
    const queryTypeLabel = queryType === 'all' ? '全データ' : '貸出中データ(ユーザー預り機有)';
    const currentTime = new Date().toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
    
    return `
      <div class="data-status-panel">
        <div class="status-panel-header">
          <div class="status-panel-icon">
            <i class="fas fa-chart-bar"></i>
          </div>
          <h4>データ状況</h4>
        </div>
        <div class="status-panel-content">
          <div class="status-panel-item" title="現在選択中の拠点名">
            <span class="status-panel-label">拠点</span>
            <span class="status-panel-value location-value">${locationName}</span>
          </div>
          <div class="status-panel-item" title="現在の表示フィルタ設定">
            <span class="status-panel-label">表示モード</span>
            <span class="status-panel-value mode-value">${queryTypeLabel}</span>
          </div>
          <div class="status-panel-item" title="現在のフィルタ条件で表示されている件数">
            <span class="status-panel-label">表示中</span>
            <span class="status-panel-value count-value">${displayedRows}件</span>
          </div>
          <div class="status-panel-item" title="拠点の全データ件数（フィルタ前）">
            <span class="status-panel-label">全体</span>
            <span class="status-panel-value total-value">${totalRows}件</span>
          </div>
          <div class="status-panel-item" title="ステータス列に「貸出」が含まれている件数">
            <span class="status-panel-label">貸出中</span>
            <span class="status-panel-value lending-value">${lendingRows}件</span>
          </div>
          <div class="status-panel-item" title="預り台数（ユーザー預り機有）：「預りユーザー機のシリアルNo.」に内容がある件数">
            <span class="status-panel-label">預り台数</span>
            <span class="status-panel-value user-keeping-value">${userKeepingRows}台</span>
          </div>
          <div class="status-panel-item" title="データが最後に取得された時刻">
            <span class="status-panel-label">最終更新</span>
            <span class="status-panel-value time-value">${currentTime}</span>
          </div>
        </div>
      </div>
    `;
  }

  // セルクリック編集機能を有効化（代替機フォーム回答シート専用）
  function enableCellEditing(data) {
    // 編集機能の初期化
    initializeCellEditing();
    
    const table = document.querySelector('#tableContainer table');
    if (!table) return;
    
    // データセル（ヘッダー以外）にクリックイベントを追加
    // mainシートは数式でデータを取得するため、代替機フォーム回答シートのみ編集可能
    const dataCells = table.querySelectorAll('td');
    dataCells.forEach((cell, index) => {
      const table = cell.closest('table');
      const headerCells = table.querySelectorAll('th');
      const columnCount = headerCells.length;
      
      const rowIndex = Math.floor(index / columnCount) + 1; // データ行番号（1から開始）
      const columnIndex = index % columnCount; // 列番号（0から開始）
      
      // セルをクリック可能にする
      cell.style.cursor = 'pointer';
      cell.title = 'クリックして編集';
      cell.classList.add('editable-cell');
      
      cell.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // 既に編集中の場合は何もしない
        if (cell.classList.contains('editing')) {
      return;
    }
        
        const currentValue = cell.textContent || '';
        startCellEdit(cell, rowIndex, columnIndex, currentValue);
      });
    });
    
    showDebugInfo('代替機フォーム回答シートのセル編集機能有効化完了', { 
      totalCells: dataCells.length,
      dataRows: data.length - 1 
    });
  }

  // 現在編集中のセル情報を格納する変数
  let currentEditingCell = null;
  
  // 現在表示中の代替機フォーム回答シート名を保持する変数
  let currentLocationSheetName = null;
  
  // 代替機フォーム回答シートの表示制御用変数
  let locationSheetDisplayCount = 10; // 初期表示件数
  let locationSheetAllData = null; // 全データを保持
  let locationSheetCurrentData = null; // 現在表示中のデータ

  // セル編集機能の初期化
  function initializeCellEditing() {
    // 編集中の場合は既存の編集をキャンセル
    if (currentEditingCell) {
      cancelCellEdit();
    }
  }

  // セル編集開始
  function startCellEdit(cell, rowIndex, columnIndex, currentValue) {
    // 他の編集中セルがあればキャンセル
    if (currentEditingCell) {
      cancelCellEdit();
    }
    
    showDebugInfo('セル編集開始', { rowIndex, columnIndex, currentValue });
    
    // 元のセル内容を保存
    const originalContent = cell.innerHTML;
    const originalValue = currentValue || '';
    
    // 編集状態の情報を保存
    currentEditingCell = {
      cell: cell,
      rowIndex: rowIndex,
      columnIndex: columnIndex,
      originalContent: originalContent,
      originalValue: originalValue
    };
    
    // 編集UIを作成
    const editContainer = document.createElement('div');
    editContainer.className = 'cell-edit-container';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'cell-edit-input';
    input.value = originalValue;
    
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'cell-edit-buttons';
    
    const confirmButton = document.createElement('button');
    confirmButton.className = 'cell-edit-confirm';
    confirmButton.innerHTML = '<i class="fas fa-check"></i>';
    confirmButton.title = '確定';
    confirmButton.onclick = function(e) {
      e.preventDefault();
      e.stopPropagation();
      confirmCellEdit(input.value);
    };
    
    const cancelButton = document.createElement('button');
    cancelButton.className = 'cell-edit-cancel';
    cancelButton.innerHTML = '<i class="fas fa-times"></i>';
    cancelButton.title = 'キャンセル';
    cancelButton.onclick = function(e) {
      e.preventDefault();
      e.stopPropagation();
      cancelCellEdit();
    };
    
    buttonContainer.appendChild(confirmButton);
    buttonContainer.appendChild(cancelButton);
    editContainer.appendChild(input);
    editContainer.appendChild(buttonContainer);
    
    // セルの内容を編集UIに置き換え
    cell.innerHTML = '';
    cell.appendChild(editContainer);
    cell.classList.add('editing');
    
    // 入力フィールドにフォーカス
    input.focus();
    input.select();
    
    // Enterキーで確定、Escapeキーでキャンセル
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        confirmCellEdit(input.value);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        cancelCellEdit();
      }
    });
  }

  // セル編集の確認
  function confirmCellEdit(newValue) {
    if (!currentEditingCell) return;
    
    const { rowIndex, columnIndex, originalValue } = currentEditingCell;
    
    // 値に変更がない場合はキャンセル
    if (newValue === originalValue) {
      cancelCellEdit();
      return;
    }
    
    // 確認ダイアログを表示
    const confirmMessage = `
      セルの内容を変更しますか？
      
      変更前: "${originalValue}"
      変更後: "${newValue}"
    `;
    
    if (!window.confirm(confirmMessage)) {
      return;
    }
    
    showDebugInfo('セル更新開始', { rowIndex, columnIndex, originalValue, newValue });
    
    // ローディング状態に変更
    const { cell } = currentEditingCell;
    cell.innerHTML = '<div class="cell-updating"><i class="fas fa-spinner fa-spin"></i> 更新中...</div>';
    
    // 現在の代替機フォーム回答シート名を取得
    const locationSheetName = getCurrentLocationSheetName();
    if (!locationSheetName) {
      showDebugInfo('代替機フォーム回答シート名が取得できません', { currentLocationSheetName });
      cancelCellEdit();
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = '代替機フォーム回答シート名を取得できませんでした。画面を再読み込みしてください。';
      return;
    }
    
    showDebugInfo('セル更新実行', { 
      location: currentLocation, 
      locationSheetName: locationSheetName,
      rowIndex, 
      columnIndex, 
      originalValue, 
      newValue 
    });
    
    // サーバーにセル更新を送信
    google.script.run
      .withSuccessHandler(function(response) {
        showDebugInfo('セル更新成功', response);
        
        if (response.success) {
          // 成功時は新しい値を表示
          cell.innerHTML = newValue || '';
          cell.classList.remove('editing');
          showPopupMessage('セルを更新しました');
          
          // 編集状態をクリア
          currentEditingCell = null;
          
          // プリロードデータ（メインシート）を更新
          updatePreloadedData();
          
          // 代替機フォーム回答シートの自動更新を実行（少し遅延させて）
          setTimeout(() => {
            refreshLocationSheet();
          }, 1000);
          
        } else {
          // エラー時は元の値に戻す
          const errorMessage = response.error || '不明なエラーが発生しました';
          showDebugInfo('セル更新エラー', { error: errorMessage });
          cancelCellEdit();
          
          const errorDiv = document.getElementById('error');
          errorDiv.textContent = 'セルの更新に失敗しました: ' + errorMessage;
        }
      })
      .withFailureHandler(function(error) {
        showDebugInfo('セル更新通信エラー', { error });
        cancelCellEdit();
        
        const errorDiv = document.getElementById('error');
        errorDiv.textContent = 'セルの更新中にエラーが発生しました: ' + error;
      })
      .updateLocationSheetCell(currentLocation, locationSheetName, rowIndex, columnIndex, newValue);
  }

  // セル編集のキャンセル
  function cancelCellEdit() {
    if (!currentEditingCell) return;
    
    const { cell, originalContent } = currentEditingCell;
    
    // 元の内容に戻す
    cell.innerHTML = originalContent;
    cell.classList.remove('editing');
    
    // 編集状態をクリア
    currentEditingCell = null;
    
    showDebugInfo('セル編集キャンセル', {});
  }

  // 現在の代替機フォーム回答シート名を取得
  function getCurrentLocationSheetName() {
    // グローバル変数から代替機フォーム回答シート名を取得
    return currentLocationSheetName;
  }

  // 代替機フォーム回答シートの自動更新
  function refreshLocationSheet() {
    const locationSheetName = getCurrentLocationSheetName();
    if (locationSheetName) {
      // 現在の表示件数を保持
      const currentDisplayCount = locationSheetDisplayCount;
      
      showDebugInfo('代替機フォーム回答シート自動更新', { 
        locationSheetName, 
        currentDisplayCount 
      });
      
      // データを再読み込み
    const errorDiv = document.getElementById('error');
    const loadingDiv = document.getElementById('loading');

    loadingDiv.style.display = 'block';
    errorDiv.textContent = '';

      google.script.run
        .withSuccessHandler(function(response) {
          loadingDiv.style.display = 'none';
          
          if (response.success) {
            // 全データを更新
            locationSheetAllData = response.data;
            // 表示件数を復元
            locationSheetDisplayCount = currentDisplayCount;
            
            // データを再表示
            displayLocationSheetData(locationSheetName);
            
            showDebugInfo('代替機フォーム回答シート自動更新完了', { locationSheetName });
          } else {
            errorDiv.textContent = `代替機フォーム回答シート「${locationSheetName}」の更新に失敗しました: ${response.error}`;
          }
        })
        .withFailureHandler(function(error) {
          loadingDiv.style.display = 'none';
          errorDiv.textContent = `代替機フォーム回答シート「${locationSheetName}」の更新中にエラーが発生しました: ${error}`;
        })
        .getLocationSheetData(currentLocation, locationSheetName, 'all');
    }
  }

  // プリロードデータ（メインシート）を更新する関数
  function updatePreloadedData() {
    if (!currentLocation) {
      showDebugInfo('プリロードデータ更新: 拠点が選択されていません', {});
            return;
          }
          
    showDebugInfo('プリロードデータ更新開始', { location: currentLocation });

    // プリロードデータがある場合のみ更新
    if (typeof preloadedData !== 'undefined' && preloadedData[currentLocation]) {
      // メインシートの最新データを取得
      google.script.run
        .withSuccessHandler(function(response) {
          if (response.success) {
            // プリロードデータを更新
              preloadedData[currentLocation] = response;
            showDebugInfo('プリロードデータ更新成功', { 
              location: currentLocation, 
              dataSize: response.data.length 
            });
          } else {
            showDebugInfo('プリロードデータ更新エラー', { 
              location: currentLocation, 
              error: response.error 
            });
          }
        })
        .withFailureHandler(function(error) {
          showDebugInfo('プリロードデータ更新通信エラー', { 
            location: currentLocation, 
            error: error 
          });
        })
        .getSpreadsheetData(currentLocation, 'all');
    } else {
      showDebugInfo('プリロードデータ更新スキップ', { 
        location: currentLocation,
        reason: 'プリロードデータが存在しません'
      });
    }
  }

  // ========================================
  // フロート横スクロールバー機能
  // ========================================
  
  let floatScrollbarInitialized = false;
  let tableScrollElement = null;
  let floatScrollElement = null;
  let isFloatScrolling = false;
  let isTableScrolling = false;

  // フロート横スクロールバーの初期化
  function initializeFloatScrollbar() {
    if (floatScrollbarInitialized) {
      if (DEBUG_MODE) {
        showDebugInfo('フロートスクロールバー初期化スキップ', { reason: '既に初期化済み' });
      }
      return;
    }
    
    tableScrollElement = document.querySelector('.table-responsive');
    floatScrollElement = document.querySelector('.float-scrollbar-inner');
    const floatScrollbar = document.getElementById('floatScrollbar');
    
    if (DEBUG_MODE) {
      showDebugInfo('フロートスクロールバー要素検索結果', {
        tableScrollElement: !!tableScrollElement,
        floatScrollElement: !!floatScrollElement,
        floatScrollbar: !!floatScrollbar,
        tableScrollElementSelector: '.table-responsive',
        floatScrollElementSelector: '.float-scrollbar-inner',
        floatScrollbarId: 'floatScrollbar'
      });
    }
    
    if (!tableScrollElement || !floatScrollElement || !floatScrollbar) {
      if (DEBUG_MODE) {
        showDebugInfo('フロートスクロールバー初期化失敗', { 
          reason: '必要な要素が見つからない',
          tableScrollElement: !!tableScrollElement,
          floatScrollElement: !!floatScrollElement,
          floatScrollbar: !!floatScrollbar
        });
      }
      return;
    }
    
    // アニメーション用スタイルを追加
    addFloatScrollbarAnimations();
    
    // フロートスクロールバーのコンテンツ幅を設定する関数
    function updateFloatScrollbarWidth() {
      const table = document.querySelector('#tableContainer table');
      if (table) {
        const tableWidth = table.scrollWidth;
        const containerWidth = tableScrollElement.clientWidth;
        
        // テーブルがコンテナより幅広い場合のみフロートスクロールバーを表示
        if (tableWidth > containerWidth) {
          const floatContent = floatScrollElement.querySelector('.float-scrollbar-content');
          floatContent.style.width = tableWidth + 'px';
          
          if (!floatScrollbar.classList.contains('visible')) {
            floatScrollbar.classList.add('visible');
            tableScrollElement.classList.add('has-float-scrollbar');
          }
        } else {
          if (floatScrollbar.classList.contains('visible')) {
            floatScrollbar.classList.remove('visible');
            tableScrollElement.classList.remove('has-float-scrollbar');
          }
        }
      }
    }
    
    // テーブルスクロールとフロートスクロールの同期
    function syncScrollPosition() {
      if (!isFloatScrolling && !isTableScrolling) {
        const scrollLeft = tableScrollElement.scrollLeft;
        floatScrollElement.scrollLeft = scrollLeft;
      }
    }
    
    // テーブルスクロール時のイベントハンドラ
    tableScrollElement.addEventListener('scroll', function() {
      if (!isFloatScrolling) {
        isTableScrolling = true;
        floatScrollbar.classList.add('scrolling');
        syncScrollPosition();
        requestAnimationFrame(() => {
          isTableScrolling = false;
          setTimeout(() => {
            floatScrollbar.classList.remove('scrolling');
          }, 200);
        });
      }
    });
    
    // フロートスクロール時のイベントハンドラ
    floatScrollElement.addEventListener('scroll', function() {
      if (!isTableScrolling) {
        isFloatScrolling = true;
        floatScrollbar.classList.add('scrolling');
        const scrollLeft = floatScrollElement.scrollLeft;
        tableScrollElement.scrollLeft = scrollLeft;
        requestAnimationFrame(() => {
          isFloatScrolling = false;
          setTimeout(() => {
            floatScrollbar.classList.remove('scrolling');
          }, 200);
        });
      }
    });
    
    // ウィンドウリサイズ時にフロートスクロールバーの表示を更新
    window.addEventListener('resize', updateFloatScrollbarWidth);
    
    // MutationObserverでテーブルの変更を監視
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'childList' || mutation.type === 'subtree') {
          // テーブルが追加/変更された場合、少し遅延してから幅を更新
          setTimeout(updateFloatScrollbarWidth, 100);
        }
      });
    });
    
    // テーブルコンテナを監視
    const tableContainer = document.getElementById('tableContainer');
    if (tableContainer) {
      observer.observe(tableContainer, {
        childList: true,
        subtree: true
      });
    }
    
    // スクロール位置の同期を定期的にチェック（フォールバック）
    setInterval(() => {
      if (!isFloatScrolling && !isTableScrolling) {
        const tableScrollLeft = tableScrollElement.scrollLeft;
        const floatScrollLeft = floatScrollElement.scrollLeft;
        
        if (Math.abs(tableScrollLeft - floatScrollLeft) > 1) {
          floatScrollElement.scrollLeft = tableScrollLeft;
        }
      }
    }, 100);
    
    floatScrollbarInitialized = true;
    
    if (DEBUG_MODE) {
      showDebugInfo('フロート横スクロールバー初期化完了', {
        tableScrollElement: !!tableScrollElement,
        floatScrollElement: !!floatScrollElement,
        floatScrollbar: !!floatScrollbar
      });
    }
  }

  // ページ読み込み時にフロートスクロールバーを初期化
  document.addEventListener('DOMContentLoaded', function() {
    if (DEBUG_MODE) {
      showDebugInfo('DOMContentLoaded: フロートスクロールバー初期化開始', {});
    }
    // 少し遅延してから初期化（他の初期化処理の後）
    setTimeout(() => {
      if (DEBUG_MODE) {
        showDebugInfo('DOMContentLoaded遅延実行: フロートスクロールバー初期化', {});
      }
      initializeFloatScrollbar();
    }, 500);
  });

  // テーブル表示後にもフロートスクロールバーの状態を更新
  function updateFloatScrollbarAfterTableLoad() {
    if (DEBUG_MODE) {
      showDebugInfo('updateFloatScrollbarAfterTableLoad呼び出し', {
        floatScrollbarInitialized: floatScrollbarInitialized,
        tableScrollElement: !!tableScrollElement
      });
    }
    
    // フロートスクロールバーが初期化されていない場合は初期化を試行
    if (!floatScrollbarInitialized) {
      if (DEBUG_MODE) {
        showDebugInfo('フロートスクロールバー未初期化のため初期化を試行', {});
      }
      initializeFloatScrollbar();
    }
    
    if (floatScrollbarInitialized) {
      const floatScrollbar = document.getElementById('floatScrollbar');
      const table = document.querySelector('#tableContainer table');
      
      if (DEBUG_MODE) {
        showDebugInfo('フロートスクロールバー更新要素チェック', {
          floatScrollbar: !!floatScrollbar,
          table: !!table,
          tableScrollElement: !!tableScrollElement
        });
      }
      
      if (table && tableScrollElement) {
        // レンダリング完了後にテーブル幅を正確に取得
        setTimeout(() => {
          const tableWidth = table.scrollWidth;
          const containerWidth = tableScrollElement.clientWidth;
          const tableOffsetWidth = table.offsetWidth;
          const tableClientWidth = table.clientWidth;
          
          if (DEBUG_MODE) {
            showDebugInfo('テーブル幅チェック（詳細）', {
              scrollWidth: tableWidth,
              offsetWidth: tableOffsetWidth,
              clientWidth: tableClientWidth,
              containerWidth: containerWidth,
              needsScrollbar: tableWidth > containerWidth,
              columns: table.querySelectorAll('th').length,
              visibleColumns: Array.from(table.querySelectorAll('th')).filter(th => window.getComputedStyle(th).display !== 'none').length
            });
          }
          
          if (tableWidth > containerWidth) {
            const floatContent = document.querySelector('.float-scrollbar-content');
          if (floatContent) {
            floatContent.style.width = tableWidth + 'px';
          }
          
          // アニメーション付きで表示
          if (!floatScrollbar.classList.contains('visible')) {
            floatScrollbar.classList.add('visible');
            tableScrollElement.classList.add('has-float-scrollbar');
            
            if (DEBUG_MODE) {
              showDebugInfo('フロートスクロールバーvisibleクラス追加', {
                classList: Array.from(floatScrollbar.classList),
                displayStyle: window.getComputedStyle(floatScrollbar).display,
                visibility: window.getComputedStyle(floatScrollbar).visibility,
                opacity: window.getComputedStyle(floatScrollbar).opacity
              });
            }
            
            // 少し遅延してからスクロール位置をリセット（アニメーション後）
            setTimeout(() => {
              tableScrollElement.scrollLeft = 0;
              floatScrollElement.scrollLeft = 0;
              
              if (DEBUG_MODE) {
                showDebugInfo('フロートスクロールバー状態確認（遅延後）', {
                  classList: Array.from(floatScrollbar.classList),
                  displayStyle: window.getComputedStyle(floatScrollbar).display,
                  visibility: window.getComputedStyle(floatScrollbar).visibility,
                  opacity: window.getComputedStyle(floatScrollbar).opacity,
                  zIndex: window.getComputedStyle(floatScrollbar).zIndex,
                  position: window.getComputedStyle(floatScrollbar).position
                });
              }
            }, 400);
          } else {
            if (DEBUG_MODE) {
              const computedStyle = window.getComputedStyle(floatScrollbar);
              showDebugInfo('フロートスクロールバー既に表示中', {
                classList: Array.from(floatScrollbar.classList),
                cssDisplay: computedStyle.display,
                cssVisibility: computedStyle.visibility,
                cssOpacity: computedStyle.opacity,
                cssZIndex: computedStyle.zIndex,
                cssPosition: computedStyle.position,
                cssBottom: computedStyle.bottom,
                cssLeft: computedStyle.left,
                cssRight: computedStyle.right,
                cssWidth: computedStyle.width,
                cssHeight: computedStyle.height,
                offsetHeight: floatScrollbar.offsetHeight,
                offsetWidth: floatScrollbar.offsetWidth,
                clientHeight: floatScrollbar.clientHeight,
                clientWidth: floatScrollbar.clientWidth,
                boundingRect: floatScrollbar.getBoundingClientRect()
              });
            }
          }
          
          if (DEBUG_MODE) {
            showDebugInfo('フロートスクロールバー表示', {
              tableWidth: tableWidth,
              containerWidth: containerWidth,
              scrollDifference: tableWidth - containerWidth
            });
            
            // テスト関数を実行して問題を診断
            setTimeout(() => {
              console.log('=== フロートスクロールバーテスト開始 ===');
              checkCSSLoadStatus();
              testFloatScrollbarVisibility();
            }, 200);
          }
        } else {
          // アニメーション付きで非表示
          if (floatScrollbar.classList.contains('visible')) {
            floatScrollbar.style.animation = 'floatScrollbarSlideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
            
            setTimeout(() => {
              floatScrollbar.classList.remove('visible');
              tableScrollElement.classList.remove('has-float-scrollbar');
              floatScrollbar.style.animation = '';
            }, 300);
          }
          
          if (DEBUG_MODE) {
            showDebugInfo('フロートスクロールバー非表示', {
              tableWidth: tableWidth,
              containerWidth: containerWidth
            });
          }
        }
        }, 50); // setTimeout の終了
      }
    }
  }

  // スクロールバーの非表示アニメーション用のスタイルを動的に追加
  function addFloatScrollbarAnimations() {
    // 既にスタイルが追加されているかチェック
    if (document.getElementById('float-scrollbar-animations')) return;
    
    const style = document.createElement('style');
    style.id = 'float-scrollbar-animations';
    style.textContent = `
      @keyframes floatScrollbarSlideDown {
        from {
          transform: translateY(0);
          opacity: 1;
        }
        to {
          transform: translateY(100%);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
  }

  // プリロードデータを使わずに強制的に最新データを取得する関数
  function loadSpreadsheetForceRefresh(location, queryType) {
    if (DEBUG_MODE) {
      showDebugInfo('強制更新データ取得開始', { location, queryType });
    }
    
    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');

    loadingDiv.style.display = 'block';
    errorDiv.textContent = '';
    tableContainer.innerHTML = '';

    try {
      if (!google || !google.script || !google.script.run) {
        throw new Error('Google Apps Scriptの実行環境が正しく初期化されていません');
      }

      google.script.run
        .withSuccessHandler(function(response) {
          if (DEBUG_MODE) {
            showDebugInfo('強制更新データ取得成功', response);
          }
          loadingDiv.style.display = 'none';
          
          if (!response) {
            errorDiv.textContent = 'エラーが発生しました : スプレッドシート内の日時の表示形式を"書式なし"に変更してください';
            tableContainer.innerHTML = '';
            return;
          }
          
          if (response.success) {
            // プリロードデータも更新
            if (typeof preloadedData !== 'undefined') {
              preloadedData[location] = response;
            }
            
            displayData(response.data, queryType);
            errorDiv.textContent = '';
          } else {
            const errorMessage = response.error || '不明なエラーが発生しました';
            errorDiv.textContent = 'エラー: ' + errorMessage;
            tableContainer.innerHTML = '';
          }

          if (response.logs && DEBUG_MODE) {
            showServerLogs(response.logs);
          }
        })
        .withFailureHandler(function(error) {
          if (DEBUG_MODE) {
            showDebugInfo('強制更新通信エラー', { error });
          }
          loadingDiv.style.display = 'none';
          errorDiv.textContent = 'エラーが発生しました: ' + error;
          tableContainer.innerHTML = '';
        })
        .getSpreadsheetData(location, queryType);
    } catch (error) {
      if (DEBUG_MODE) {
        showDebugInfo('強制更新処理エラー', { error });
      }
      loadingDiv.style.display = 'none';
      errorDiv.textContent = 'クライアントサイドでエラーが発生しました: ' + error;
      tableContainer.innerHTML = '';
    }
  }

  // サーバーサイドの設定をテストする関数
  function testServerConfiguration() {
    console.log('🔧 サーバーサイド設定テスト開始...');
    
    // Google Apps Script環境の確認
    google.script.run
      .withSuccessHandler(function(response) {
        console.log('✅ サーバーサイド設定テスト成功:', response);
      })
      .withFailureHandler(function(error) {
        console.log('❌ サーバーサイド設定テストエラー:', error);
      })
      .getDestinationSheets();
  }
  
  // サマリーシートの詳細診断を実行する関数
  function diagnoseSummarySheetClient() {
    console.log('🔍 サマリーシート診断開始...');
    
    google.script.run
      .withSuccessHandler(function(response) {
        console.log('🔍 サマリーシート診断結果:', response);
        
        if (response.success) {
          console.log('✅ 診断成功');
          console.log('📊 シート情報:', response.sheetInfo);
          console.log('🔧 実際の関数結果:', response.functionResult);
        } else {
          console.log('❌ 診断失敗:', response.error);
        }
        
        // 診断ログを表示
        if (response.diagnostics && response.diagnostics.length > 0) {
          console.log('📋 診断ログ:');
          response.diagnostics.forEach((log, index) => {
            console.log(`  ${index + 1}. [${log.timestamp}] ${log.message}`, log.data);
          });
        }
        
        // デバッグモードでUI表示
        if (DEBUG_MODE) {
          showDebugInfo('サマリーシート診断完了', response);
        }
      })
      .withFailureHandler(function(error) {
        console.log('❌ サマリーシート診断通信エラー:', error);
      })
      .diagnoseSummarySheet();
  }
  
  // フロートスクロールバーの状態をテストする関数
  function testFloatScrollbarVisibility() {
    const floatScrollbar = document.getElementById('floatScrollbar');
    if (!floatScrollbar) {
      console.log('❌ フロートスクロールバー要素が見つかりません');
      return;
    }
    
    const computedStyle = window.getComputedStyle(floatScrollbar);
    const rect = floatScrollbar.getBoundingClientRect();
    
    console.log('🔍 フロートスクロールバー詳細状態:');
    console.log('要素:', floatScrollbar);
    console.log('classList:', Array.from(floatScrollbar.classList));
    console.log('CSS display:', computedStyle.display);
    console.log('CSS visibility:', computedStyle.visibility);
    console.log('CSS opacity:', computedStyle.opacity);
    console.log('CSS position:', computedStyle.position);
    console.log('CSS zIndex:', computedStyle.zIndex);
    console.log('CSS bottom:', computedStyle.bottom);
    console.log('CSS transform:', computedStyle.transform);
    console.log('boundingRect:', rect);
    console.log('offsetHeight:', floatScrollbar.offsetHeight);
         console.log('offsetWidth:', floatScrollbar.offsetWidth);
     console.log('scrollHeight:', floatScrollbar.scrollHeight);
     console.log('scrollWidth:', floatScrollbar.scrollWidth);
     
     // ビューポート情報を追加
     console.log('🖥️ ビューポート情報:');
     console.log('window.innerHeight:', window.innerHeight);
     console.log('window.innerWidth:', window.innerWidth);
     console.log('document.documentElement.clientHeight:', document.documentElement.clientHeight);
     console.log('document.documentElement.clientWidth:', document.documentElement.clientWidth);
     console.log('window.scrollY:', window.scrollY);
     console.log('window.scrollX:', window.scrollX);
     
     // iframe内での実行かチェック
     console.log('🖼️ フレーム情報:');
     console.log('window.self === window.top:', window.self === window.top);
     console.log('window.frameElement:', window.frameElement);
     if (window.frameElement) {
       console.log('親フレームサイズ:', {
         width: window.frameElement.offsetWidth,
         height: window.frameElement.offsetHeight
       });
     }
     
     // フロートスクロールバーがビューポート内にあるかチェック
     const isInViewport = rect.top >= 0 && rect.top <= window.innerHeight;
     console.log('📍 ビューポート内表示判定:', isInViewport);
     console.log('スクロールバー位置 (top):', rect.top);
     console.log('ビューポート高さ:', window.innerHeight);
     console.log('差分:', window.innerHeight - rect.top);
    
         // ビューポート外の場合は自動修正
     if (!isInViewport) {
       console.log('⚠️ フロートスクロールバーがビューポート外に配置されています。修正します...');
       floatScrollbar.style.position = 'fixed';
       floatScrollbar.style.bottom = '0px';
       floatScrollbar.style.left = '0px';
       floatScrollbar.style.right = '0px';
       floatScrollbar.style.zIndex = '9999';
       floatScrollbar.style.transform = 'none';
       
       // 修正後の位置を確認
       setTimeout(() => {
         const newRect = floatScrollbar.getBoundingClientRect();
         const nowInViewport = newRect.top >= 0 && newRect.top <= window.innerHeight;
         console.log('🔧 修正後の位置:', newRect);
         console.log('修正後のビューポート内判定:', nowInViewport);
       }, 100);
     }
     
     // 強制的に表示テスト
     console.log('🧪 強制表示テスト実行...');
     floatScrollbar.style.display = 'block !important';
     floatScrollbar.style.visibility = 'visible !important';
     floatScrollbar.style.opacity = '1 !important';
     floatScrollbar.style.zIndex = '9999 !important';
     floatScrollbar.style.position = 'fixed !important';
     floatScrollbar.style.bottom = '0px !important';
     floatScrollbar.style.left = '0px !important';
     floatScrollbar.style.right = '0px !important';
    
    setTimeout(() => {
      const newRect = floatScrollbar.getBoundingClientRect();
      const newComputedStyle = window.getComputedStyle(floatScrollbar);
      console.log('強制表示後のboundingRect:', newRect);
      console.log('強制表示後のCSS display:', newComputedStyle.display);
      console.log('強制表示後のCSS visibility:', newComputedStyle.visibility);
      console.log('強制表示後のCSS opacity:', newComputedStyle.opacity);
         }, 100);
   }
   
   // CSS読み込み状況をチェックする関数
   function checkCSSLoadStatus() {
     const styleSheets = Array.from(document.styleSheets);
     console.log('📋 CSS読み込み状況:');
     console.log('総スタイルシート数:', styleSheets.length);
     
     styleSheets.forEach((sheet, index) => {
       try {
         console.log(`スタイルシート ${index + 1}:`, {
           href: sheet.href,
           rules: sheet.cssRules ? sheet.cssRules.length : 'アクセス不可',
           disabled: sheet.disabled
         });
       } catch (e) {
         console.log(`スタイルシート ${index + 1}: アクセスエラー`, e.message);
       }
     });
     
     // .float-scrollbar.visible の具体的なルールを探す
     let floatScrollbarRule = null;
     styleSheets.forEach(sheet => {
       try {
         if (sheet.cssRules) {
           Array.from(sheet.cssRules).forEach(rule => {
             if (rule.selectorText && rule.selectorText.includes('.float-scrollbar.visible')) {
               floatScrollbarRule = rule;
               console.log('🎯 .float-scrollbar.visible ルール発見:', rule.cssText);
             }
           });
         }
       } catch (e) {
         // CORS制限でアクセスできない場合は無視
       }
     });
     
     if (!floatScrollbarRule) {
       console.log('⚠️ .float-scrollbar.visible のCSSルールが見つかりません');
     }
   }
   
  // ========================================
  // 新しいシートタイプ制御関数
  // ========================================
  
  // 拠点選択の表示/非表示制御
  function updateLocationVisibility(sheetType) {
    const locationSelector = document.querySelector('.location-selector');
    
    if (sheetType === 'normal') {
      locationSelector.style.display = 'block';
    } else {
      locationSelector.style.display = 'none';
      // 拠点選択をリセット
      document.getElementById('location').value = '';
      currentLocation = '';
    }
  }
  
  // 監査シート選択の表示/非表示制御
  function updateAuditSheetVisibility(sheetType) {
    const auditSheetSelector = document.querySelector('.audit-sheet-selector');
    const refreshAuditButton = document.getElementById('refreshAuditButton');
    const lastUpdateTimeAudit = document.getElementById('lastUpdateTimeAudit');
    
    if (sheetType === 'audit') {
      auditSheetSelector.style.display = 'block';
    } else {
      auditSheetSelector.style.display = 'none';
      // 監査シート選択をリセット
      document.getElementById('auditSheet').value = '';
      // 更新ボタンを無効化
      if (refreshAuditButton) {
        refreshAuditButton.disabled = true;
      }
      // 監査データの時刻表示を隠す
      if (lastUpdateTimeAudit) {
        lastUpdateTimeAudit.style.display = 'none';
      }
    }
  }

  // サマリー更新セクションの表示/非表示制御
  function updateSummaryRefreshVisibility(sheetType) {
    const summaryRefreshSelector = document.querySelector('.summary-refresh-selector');
    
    if (sheetType === 'summary') {
      summaryRefreshSelector.style.display = 'block';
    } else {
      summaryRefreshSelector.style.display = 'none';
    }
  }
  
  // クエリセレクターの表示/非表示制御
  function updateQuerySelectorVisibility(sheetType) {
    const querySelector = document.querySelector('.query-selector');
    
    if (sheetType === 'normal') {
      querySelector.style.display = 'block';
    } else {
      querySelector.style.display = 'none';
    }
  }
  
  // データタイプ変更イベントハンドラー
  function handleDataTypeChange() {
    const dataTypeId = document.getElementById('dataType').value;
    
    showDebugInfo('データタイプ変更', { dataTypeId });
    
    if (!dataTypeId) {
      // データタイプが選択されていない場合
      document.querySelector('.location-selector').style.display = 'none';
      document.querySelector('.audit-sheet-selector').style.display = 'none';
      document.querySelector('.summary-refresh-selector').style.display = 'none';
      document.querySelector('.query-selector').style.display = 'none';
      
      const tableContainer = document.getElementById('tableContainer');
      const errorDiv = document.getElementById('error');
      tableContainer.innerHTML = '';
      errorDiv.textContent = '';
      return;
    }
    
    // 選択されたデータタイプの情報を取得
    const selectedDataType = dataTypeMasterData.find(dt => dt.dataTypeId === dataTypeId);
    if (!selectedDataType) {
      console.error('選択されたデータタイプが見つかりません:', dataTypeId);
      return;
    }
    
    // データタイプに応じてUIを更新
    updateUIForDataType(selectedDataType);
    
    // テーブルをクリア
    const tableContainer = document.getElementById('tableContainer');
    const errorDiv = document.getElementById('error');
    tableContainer.innerHTML = '';
    errorDiv.textContent = '';
    
    // データを読み込み
    if (DEBUG_MODE) {
      showDebugInfo('loadDataBasedOnDataType呼び出し', { dataTypeId });
    }
    loadDataBasedOnDataType();
  }
  
  // データタイプに応じてUIを更新
  function updateUIForDataType(dataType) {
    const dataTypeId = dataType.dataTypeId;
    
    // 各セクションの表示/非表示を制御
    if (dataTypeId === 'NORMAL') {
      // 通常データの場合
      document.querySelector('.location-selector').style.display = 'block';
      document.querySelector('.audit-sheet-selector').style.display = 'none';
      document.querySelector('.summary-refresh-selector').style.display = 'none';
      document.querySelector('.query-selector').style.display = 'block';
    } else if (dataTypeId === 'AUDIT') {
      // 監査データの場合
      document.querySelector('.location-selector').style.display = 'none';
      document.querySelector('.audit-sheet-selector').style.display = 'block';
      document.querySelector('.summary-refresh-selector').style.display = 'none';
      document.querySelector('.query-selector').style.display = 'none';
    } else if (dataTypeId === 'SUMMARY') {
      // サマリーデータの場合
      document.querySelector('.location-selector').style.display = 'none';
      document.querySelector('.audit-sheet-selector').style.display = 'none';
      document.querySelector('.summary-refresh-selector').style.display = 'block';
      document.querySelector('.query-selector').style.display = 'none';
    } else {
      // その他のデータタイプ（カスタム）
      document.querySelector('.location-selector').style.display = 'block';
      document.querySelector('.audit-sheet-selector').style.display = 'none';
      document.querySelector('.summary-refresh-selector').style.display = 'none';
      document.querySelector('.query-selector').style.display = 'block';
    }
  }
  
  // 監査シート変更イベントハンドラー
  function handleAuditSheetChange() {
    const auditSheet = document.getElementById('auditSheet').value;
    const refreshAuditButton = document.getElementById('refreshAuditButton');
    
    showDebugInfo('監査シート変更', { auditSheet });
    
    // 監査シートが選択されたら更新ボタンを有効化
    if (refreshAuditButton) {
      refreshAuditButton.disabled = !auditSheet;
    }
    
    // 該当監査シートの最終更新時刻を表示
    if (auditSheet) {
      displayAuditSheetUpdateTime(auditSheet);
    } else {
      // 監査シートが選択されていない場合は時刻表示を隠す
      const lastUpdateElement = document.getElementById('lastUpdateTimeAudit');
      if (lastUpdateElement) {
        lastUpdateElement.style.display = 'none';
      }
    }
    
    loadDataBasedOnDataType();
  }
  
  // データタイプに基づいてデータを読み込み
  function loadDataBasedOnDataType() {
    const dataTypeId = document.getElementById('dataType').value;
    const locationSelect = document.getElementById('location');
    const auditSheet = document.getElementById('auditSheet').value;
    const queryType = document.querySelector('input[name="queryType"]:checked')?.value || 'all';
    
    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('tableContainer');
    const loadingDiv = document.getElementById('loading');
    
    // デバッグ情報を追加
    if (DEBUG_MODE) {
      showDebugInfo('loadDataBasedOnDataType実行', {
        dataTypeId: dataTypeId,
        locationValue: locationSelect ? locationSelect.value : 'locationSelect not found',
        auditSheet: auditSheet,
        queryType: queryType
      });
    }
    
    errorDiv.textContent = '';
    tableContainer.innerHTML = '';
    
    if (!dataTypeId) {
      return;
    }
    
    if (dataTypeId === 'NORMAL') {
      // 通常データ：拠点選択が必要
      const location = locationSelect ? locationSelect.value : '';
      if (!location) {
        errorDiv.textContent = '拠点を選択してください';
        if (DEBUG_MODE) {
          showDebugInfo('拠点未選択エラー', {
            locationSelectExists: !!locationSelect,
            locationSelectValue: location
          });
        }
        return;
      }
      const deviceTypeSelect = document.getElementById('deviceType');
      const selectedDeviceType = deviceTypeSelect ? deviceTypeSelect.value : 'terminal';
      loadSpreadsheet(location, queryType, selectedDeviceType);
      
    } else if (dataTypeId === 'AUDIT') {
      // 監査データ：監査シート選択が必要
      if (!auditSheet) {
        errorDiv.textContent = '監査シートを選択してください';
        return;
      }
      
      loadingDiv.style.display = 'block';
      
      google.script.run
        .withSuccessHandler(function(response) {
          loadingDiv.style.display = 'none';
          
          if (response.success) {
            // 監査データの場合、ヘッダー行を調整
            let adjustedData = response.data;
            if (response.metadata && response.metadata.isAuditData && response.metadata.headerRowIndex >= 0) {
              const headerRowIndex = response.metadata.headerRowIndex;
              if (headerRowIndex < response.data.length) {
                // ヘッダー行を先頭に移動
                const headerRow = response.data[headerRowIndex];
                const dataRows = response.data.slice(headerRowIndex + 1);
                adjustedData = [headerRow, ...dataRows];
                
                showDebugInfo('監査データのヘッダー行を調整', {
                  originalHeaderRowIndex: headerRowIndex,
                  adjustedDataLength: adjustedData.length,
                  headerRow: headerRow
                });
              }
            }
            
            displayData(adjustedData, 'all', 'audit');
            errorDiv.textContent = '';
            
            // 最終更新時刻を表示（監査シートごと）
            updateLastUpdateTime('lastUpdateTimeAudit', 'lastUpdateTimeAuditText', auditSheet);
            
            if (typeof showPopupMessage === 'function') {
              showPopupMessage(`${response.metadata.sheetType}を読み込みました`);
            }
          } else {
            errorDiv.textContent = `監査データの取得に失敗しました: ${response.error}`;
            tableContainer.innerHTML = '';
          }
          
          if (response.logs && DEBUG_MODE) {
            showServerLogs(response.logs);
          }
        })
        .withFailureHandler(function(error) {
          loadingDiv.style.display = 'none';
          errorDiv.textContent = `監査データの取得中にエラーが発生しました: ${error}`;
          tableContainer.innerHTML = '';
        })
        .getDestinationSheetData(auditSheet, 'all');
        
    } else if (sheetType === 'summary') {
      // サマリーデータ：即座に読み込み
      if (DEBUG_MODE) {
        showDebugInfo('サマリーデータ読み込み開始', {});
        // サーバーサイド設定もテスト
        testServerConfiguration();
        // サマリーシート診断も実行
        diagnoseSummarySheetClient();
      }
      
      loadingDiv.style.display = 'block';
      
      try {
        if (!google || !google.script || !google.script.run) {
          throw new Error('Google Apps Scriptの実行環境が正しく初期化されていません');
        }
        
        google.script.run
          .withSuccessHandler(function(response) {
            if (DEBUG_MODE) {
              showDebugInfo('サマリーデータ取得成功', {
                response: response,
                responseType: typeof response,
                responseNull: response === null,
                responseUndefined: response === undefined,
                responseString: String(response)
              });
            }
            
            loadingDiv.style.display = 'none';
            
            if (!response) {
              errorDiv.textContent = 'エラーが発生しました : スプレッドシート内の日時の表示形式を"書式なし"に変更してください';
              tableContainer.innerHTML = '';
              
              // サーバーサイドのログを強制取得
              if (DEBUG_MODE) {
                console.log('⚠️ レスポンスがnullのため、サーバーログを確認します...');
                google.script.run
                  .withSuccessHandler(function(logResponse) {
                    console.log('📋 サーバーログ取得結果:', logResponse);
                    if (logResponse && logResponse.logs) {
                      showServerLogs(logResponse.logs);
                    }
                  })
                  .withFailureHandler(function(error) {
                    console.log('❌ サーバーログ取得エラー:', error);
                  })
                  .getDestinationSheetData('サマリー', 'all');
              }
              return;
            }
            
            if (response.success) {
              displayData(response.data, 'all', 'summary');
              errorDiv.textContent = '';
              
              // 最終更新時刻を表示
              updateLastUpdateTime('lastUpdateTimeSummary', 'lastUpdateTimeSummaryText');
              
              if (typeof showPopupMessage === 'function') {
                showPopupMessage('サマリーデータを読み込みました');
              }
            } else {
              const errorMessage = response.error || '不明なエラーが発生しました';
              errorDiv.textContent = `サマリーデータの取得に失敗しました: ${errorMessage}`;
              tableContainer.innerHTML = '';
            }
            
            if (response.logs && DEBUG_MODE) {
              showServerLogs(response.logs);
            }
          })
          .withFailureHandler(function(error) {
            if (DEBUG_MODE) {
              showDebugInfo('サマリーデータ通信エラー', { error });
            }
            
            loadingDiv.style.display = 'none';
            errorDiv.textContent = `サマリーデータの取得中にエラーが発生しました: ${error}`;
            tableContainer.innerHTML = '';
          })
          .getDestinationSheetData('サマリー', 'all');
      } catch (error) {
        if (DEBUG_MODE) {
          showDebugInfo('サマリーデータ処理エラー', { error });
        }
        
        loadingDiv.style.display = 'none';
        errorDiv.textContent = `クライアントサイドでエラーが発生しました: ${error}`;
        tableContainer.innerHTML = '';
      }
    }
  }
  
  // 拠点変更ハンドラーを更新（通常データ選択時のみ動作）
  const originalHandleLocationChange = handleLocationChange;
  handleLocationChange = function() {
    const dataTypeId = document.getElementById('dataType').value;
    
    if (dataTypeId === 'NORMAL' || !dataTypeId || (dataTypeId && dataTypeId !== 'AUDIT' && dataTypeId !== 'SUMMARY')) {
      // 通常データまたはカスタムデータタイプの場合のみ既存のロジックを実行
      originalHandleLocationChange();
      
      // 拠点が選択されたらデータを読み込み
      const location = document.getElementById('location').value;
      if (location && dataTypeId) {
        loadDataBasedOnDataType();
      }
    } else {
      // 監査データやサマリーデータの場合は何もしない
      if (DEBUG_MODE) {
        showDebugInfo('拠点変更（通常データ以外のため無視）', { dataTypeId });
      }
    }
  };

</script> 